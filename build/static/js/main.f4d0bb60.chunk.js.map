{"version":3,"sources":["Assets/Icons/source.png","Assets/Icons/destination.png","Assets/Icons/wall.png","Assets/Icons/weight.png","Assets/Icons/unvisited.png","Assets/Icons/visited.png","Assets/Icons/path.png","gridOptions.js","Components/Cell.js","Components/Row.js","Components/Grid.js","Algorithms/searchingAlgorithms.js","Components/SearchingAlgorithmButton.js","Algorithms/mazeAlgorithms.js","Components/MazeAlgorithmButton.js","Components/ControlPanel.js","Components/App.js","index.js"],"names":["module","exports","gridOptions","disableUserInteraction","document","querySelectorAll","forEach","elem","disabled","enableUserInteraction","animationLaunched","animationOnDrop","isAnimated","source","destination","isSourceDragged","isDestinationDragged","chozenAlgorithmCallback","a","matrix","delay","clicked","wpressed","sourceDragged","destinationDragged","getSize","this","length","isSource","i","j","isDestination","isUnvisited","includes","class","isWall","isWeighted","weighted","isVisited","isPath","clearPath","row","cell","update","clearBoard","Cell","position","useState","options","setOptions","classList","handleMouseOver","prevSource_i","prevSource_j","prevSourceOptions","prevDestination_i","prevDestination_j","prevDestinationOptions","id","onDragStart","e","preventDefault","className","onMouseDown","button","onMouseOver","Row","columnCount","cells","Array","fill","map","_","key","Grid","rowCount","startNodePosition","endNodePosition","rows","toString","start_i","start_j","end_i","end_j","handleMouseUp","handleMouseLeave","onMouseUp","onMouseLeave","runAlgorithm","name","searchingAlgorithms","ReferenceError","searchingAlgorithmsFullNames","bfs","dfs","dijkstra","astar","animateCell","state","time","Promise","resolve","setTimeout","src","dst","mat","n","m","visited","isValid","queue","distance","path","addends","current","shift","x","y","push","newX","newY","search","has","add","foundPath","Set","unvisited","prev","distances","Infinity","stringify","indexify","vertex","split","idx","Number","extractMin","minDistance","minDistanceVertex","verticies","keys","v","delete","getNeighbors","neighbors","size","neighbor","alt","shortestPath","reverse","openSet","gScore","fScore","getHeruistic","Math","abs","minFScore","minFScoreVertex","tentative_gScore","currentNode","SearchingAlgorithmButton","algorithmName","handleClick","onClick","runMazeAlgorithm","mazeAlgorithms","mazeAlgorithmsFullNames","recursiveDivision","randomizedDFS","binaryTree","primsRandomized","kruskalsRandomized","randInt","min","max","floor","random","chooseOrientation","height","width","randWallIndex","from","to","wallIndex","indicies","randHoleIndex","holeIndex","col","divide","orientation","sourceNeighbors","filter","every","randIndex","destinationNeighbors","getNeigborsWithDistance","shuffled","l","temp","pop","getNeigbors","getHoleNeighbors","wallI","wallJ","holeI","holeJ","holeNeighbors","holeNeighbor","passageJ","passageI","middleRow","middleCol","extractRandomVertexFromUnvisitedSet","randVertex","getVisitedNeigbors","r","c","getWallNeighbors","getUnvisitedNeigbors","vi","vj","visitedNeigbors","all","isValidVertex","getAllPossibleNeighbors","visitedVertices","unvisitedEdges","possibleNeigbors","edge","extractRandomEdgeFromUnvisitedEdgesSet","addSurroundingWallsToEdge","v1","v2","i1","j1","i2","j2","vm","wall","adj","areConnected","curr","stack","im","jm","MazeAlgorithmButton","ControlPanel","speedInput","useRef","isAnimatedCheckBox","anmationOnDrop","useEffect","value","checked","handleWDown","handleWUp","window","addEventListener","removeEventListener","htmlFor","ref","type","onChange","target","sourceIcon","destinationIcon","wallIcon","weightIcon","unvisitedIcon","visitedIcon","pathIcon","App","title","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.f4d0bb60.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAA5QAAAOUBj+WbPAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAErSURBVFiF7ZZBSgNBFERfqWQXoqDiMngKl55AdOtCFDyAJ/AcgoLiRSQ7zyAoCAoRJERECKL8LJKRyZ8/o0KcuOiCv6kpeh7dNc1gZmQDLAHPgAFb+Wd/NQtMqgV8AGfAgaR1pquemV3mDQ+Q6RPYHk9eN8CV81aBHee9A+fBunuSOmZ2/+W4I2gDXeCE0TH4ufBbCGwEuX603eO123lvrmQHalMCKCshwC3w4LxHSZvOWwY6zhsEOYBGwako4VFQon2KhbsOcotBLptUwv8FUFXCpqQ15wl4cl4vyDWDHMBKwUk3YQKYNUDVVxBpV5L/R5gPci1J/ZL3vf0U4Bg4/R3ftxqY2QRYFcCrmXWnDFDQzDuQABJAAkgAZQDR/V4LwAuj6/kQuKsDYAjlHSrEjxxhcgAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG0AAABuCAYAAAAtbJ34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAEYSURBVHhe7dHBCcAwAAMxp/vv3ObRJQQnMB7gzrb3LpDn/0CKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigonG2D4DMAdvmC+R4AAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAB4CAYAAAAnrQZhAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIVSURBVHhe7dGhcUMBFMTAdJ/u0ohJYNg31xwwjN4IbAX79f3zenJPsUcVe1SxRxV7VLFHFXtUsUcVe1SxR30U+/v35B9ZR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI7oo9j4FHtUsUcVe1SxRxV7VLFHFXtUsUcVe9LreQNncxQk3K89qQAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIsSURBVHhe7dgxUQMAFAVB3KMhpjCSGSwEAWyRDt6fK1bBdffx+fV85a4CH1fg4wp8XIGPK/BxBT6uwMcV+Li3Az8e3/lH1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqN5O3A2VTg4wp8XIGPK/BxBT6uwMcV+LgCH1fg494OrF2Wv6NGvz1fP6xss6BalwdDAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAABtCAYAAABAz1RVAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAEUSURBVHhe7dExDQAwDMCwbvw5d89IRLKfAMjZnR1y7i8xxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2Vc0swD6O0D1yemuPIAAAAASUVORK5CYII=\"","const gridOptions = {\r\n  disableUserInteraction: function () {\r\n    document.querySelectorAll(\"#controlPanel button\").forEach((elem) => (elem.disabled = true));\r\n  },\r\n  enableUserInteraction: function () {\r\n    document.querySelectorAll(\"#controlPanel button\").forEach((elem) => (elem.disabled = false));\r\n  },\r\n  animationLaunched: false,\r\n  animationOnDrop: true,\r\n  isAnimated: true,\r\n  source: [],\r\n  destination: [],\r\n  isSourceDragged: false,\r\n  isDestinationDragged: false,\r\n  chozenAlgorithmCallback: async () => {},\r\n  matrix: null,\r\n  delay: 0,\r\n  clicked: false,\r\n  wpressed: false,\r\n  sourceDragged: false,\r\n  destinationDragged: false,\r\n  getSize: function () {\r\n    return [this.matrix.length, this.matrix[0].length];\r\n  },\r\n  isSource: function (i, j) {\r\n    return this.matrix[i][j].isSource;\r\n  },\r\n  isDestination: function (i, j) {\r\n    return this.matrix[i][j].isDestination;\r\n  },\r\n  isUnvisited: function (i, j) {\r\n    return [\"unvisited\", \"unvisited-animated\"].includes(this.matrix[i][j].class);\r\n  },\r\n\r\n  isWall: function (i, j) {\r\n    return [\"wall\", \"wall-animated\"].includes(this.matrix[i][j].class);\r\n  },\r\n  isWeighted: function (i, j) {\r\n    return this.matrix[i][j].weighted;\r\n  },\r\n  isVisited: function (i, j) {\r\n    return [\"visited\", \"visited-animated\"].includes(this.matrix[i][j].class);\r\n  },\r\n  isPath: function (i, j) {\r\n    return [\"path\", \"path-animated\"].includes(this.matrix[i][j].class);\r\n  },\r\n  clearPath: function () {\r\n    for (let row of this.matrix) {\r\n      for (let cell of row) {\r\n        if ([\"path\", \"path-animated\", \"visited\", \"visited-animated\"].includes(cell.class)) {\r\n          cell.update({\r\n            ...cell,\r\n            class: \"unvisited\",\r\n          });\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  clearBoard: function () {\r\n    for (let row of this.matrix) {\r\n      for (let cell of row) {\r\n        cell.update({\r\n          ...cell,\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n        });\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default gridOptions;\r\n","import React, { useState } from \"react\";\r\nimport gridOptions from \"../gridOptions\";\r\nimport \"../Assets/Styles/cell.css\";\r\n\r\nconst Cell = ({ position: { i, j } }) => {\r\n  const [options, setOptions] = useState({\r\n    class: gridOptions.matrix[i][j].class,\r\n    weighted: gridOptions.matrix[i][j].weighted,\r\n    isSource: gridOptions.matrix[i][j].isSource,\r\n    isDestination: gridOptions.matrix[i][j].isDestination,\r\n  });\r\n  gridOptions.matrix[i][j].update = setOptions;\r\n  gridOptions.matrix[i][j].class = options.class;\r\n  gridOptions.matrix[i][j].weighted = options.weighted;\r\n  gridOptions.matrix[i][j].isSource = options.isSource;\r\n  gridOptions.matrix[i][j].isDestination = options.isDestination;\r\n\r\n  let classList = \"cell \" + (options.isSource ? \"source \" : \"\") + (options.isDestination ? \"destination \" : \"\");\r\n  if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged || !gridOptions.isAnimated) {\r\n    // if animation is turned off or source / destination are being dragged (and dropped), then set\r\n    // classes without \"-animated\" suffixes for rendering WITHOUT animation\r\n    classList += options.class + (options.weighted ? \" weight \" : \"\");\r\n  } else {\r\n    // else add \"-animated\" suffix to the end of the animated classes for rendering WITH animation\r\n    classList += `${options.class}-animated ` + (options.weighted ? \"weight-animated \" : \"\");\r\n  }\r\n\r\n  const handleMouseDown = (e) => {\r\n    if (e.button !== 0 || gridOptions.animationLaunched) return;\r\n\r\n    gridOptions.clicked = true;\r\n\r\n    if (gridOptions.matrix[i][j].isSource) {\r\n      gridOptions.isSourceDragged = true;\r\n    } else if (gridOptions.matrix[i][j].isDestination) {\r\n      gridOptions.isDestinationDragged = true;\r\n    } else {\r\n      if (!gridOptions.wpressed) {\r\n        setOptions({\r\n          ...options,\r\n          weighted: false,\r\n          class: options.class === \"wall\" ? \"unvisited\" : \"wall\",\r\n        });\r\n      } else if (gridOptions.wpressed) {\r\n        setOptions({\r\n          ...options,\r\n          class: \"unvisited\",\r\n          weighted: !options.weighted,\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleMouseOver = async () => {\r\n    if (!gridOptions.clicked || gridOptions.matrix[i][j].isSource || gridOptions.matrix[i][j].isDestination) return;\r\n\r\n    if (gridOptions.isSourceDragged) {\r\n      gridOptions.clearPath();\r\n      const [prevSource_i, prevSource_j] = gridOptions.source;\r\n      const prevSourceOptions = gridOptions.matrix[prevSource_i][prevSource_j];\r\n\r\n      gridOptions.matrix[prevSource_i][prevSource_j].update({\r\n        ...prevSourceOptions,\r\n        isSource: false,\r\n      });\r\n      gridOptions.source = [i, j];\r\n\r\n      gridOptions.matrix[i][j].update({\r\n        ...options,\r\n        isSource: true,\r\n      });\r\n    } else if (gridOptions.isDestinationDragged) {\r\n      gridOptions.clearPath();\r\n      const [prevDestination_i, prevDestination_j] = gridOptions.destination;\r\n      const prevDestinationOptions = gridOptions.matrix[prevDestination_i][prevDestination_j];\r\n      gridOptions.matrix[prevDestination_i][prevDestination_j].update({\r\n        ...prevDestinationOptions,\r\n        isDestination: false,\r\n      });\r\n      gridOptions.destination = [i, j];\r\n      gridOptions.matrix[i][j].update({\r\n        ...options,\r\n        isDestination: true,\r\n      });\r\n    } else if (gridOptions.wpressed) {\r\n      // drawing a weighted node\r\n      setOptions({\r\n        ...options,\r\n        class: \"unvisited\",\r\n        weighted: !options.weighted,\r\n      });\r\n    } else {\r\n      // drawing a wall\r\n      setOptions({\r\n        ...options,\r\n        weighted: false,\r\n        class: options.class === \"wall\" ? \"unvisited\" : \"wall\",\r\n      });\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div\r\n      id={i + \",\" + j}\r\n      onDragStart={(e) => {\r\n        e.preventDefault();\r\n      }}\r\n      className={classList}\r\n      onMouseDown={handleMouseDown}\r\n      onMouseOver={handleMouseOver}\r\n    />\r\n  );\r\n};\r\n\r\nexport default Cell;\r\n","import React from \"react\";\r\nimport Cell from \"./Cell\";\r\nimport \"../Assets/Styles/row.css\";\r\n\r\nconst Row = ({ i, columnCount }) => {\r\n  const cells = new Array(columnCount).fill().map((_, j) => {\r\n    return <Cell position={{ i, j }} key={i + \",\" + j} />;\r\n  });\r\n  return <div className=\"row\">{cells}</div>;\r\n};\r\n\r\nexport default Row;\r\n","import React from \"react\";\r\nimport Row from \"./Row\";\r\nimport gridOptions from \"../gridOptions\";\r\nimport \"../Assets/Styles/grid.css\";\r\n\r\nconst Grid = ({ rowCount, columnCount, startNodePosition, endNodePosition }) => {\r\n  const rows = new Array(rowCount).fill().map((_, i) => <Row key={i.toString()} i={i} columnCount={columnCount} />);\r\n  gridOptions.matrix = new Array(rowCount);\r\n  for (let i = 0; i < rowCount; ++i) {\r\n    gridOptions.matrix[i] = new Array(columnCount);\r\n    for (let j = 0; j < columnCount; ++j) {\r\n      gridOptions.matrix[i][j] = { class: \"unvisited\", weighted: false };\r\n    }\r\n  }\r\n  const [start_i, start_j] = startNodePosition;\r\n  const [end_i, end_j] = endNodePosition;\r\n  gridOptions.matrix[start_i][start_j].isSource = true;\r\n  gridOptions.matrix[end_i][end_j].isDestination = true;\r\n  gridOptions.source = [start_i, start_j];\r\n  gridOptions.destination = [end_i, end_j];\r\n\r\n  const handleMouseUp = async (e) => {\r\n    if (e.button !== 0) return;\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      gridOptions.clearPath();\r\n      if (gridOptions.isSourceDragged) {\r\n        const [i, j] = gridOptions.source;\r\n        gridOptions.matrix[i][j].update({\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n          isSource: true,\r\n          isDestination: false,\r\n        });\r\n      } else if (gridOptions.isDestinationDragged) {\r\n        const [i, j] = gridOptions.destination;\r\n        gridOptions.matrix[i][j].update({\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n          isSource: false,\r\n          isDestination: true,\r\n        });\r\n      }\r\n      if (gridOptions.animationOnDrop) {\r\n        await gridOptions.chozenAlgorithmCallback();\r\n      }\r\n    }\r\n    gridOptions.isSourceDragged = false;\r\n    gridOptions.isDestinationDragged = false;\r\n    gridOptions.clicked = false;\r\n    gridOptions.wpressed = false;\r\n  };\r\n\r\n  const handleMouseLeave = async () => {\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      gridOptions.clearPath();\r\n      if (gridOptions.isSourceDragged) {\r\n        const [i, j] = gridOptions.source;\r\n        gridOptions.matrix[i][j].update({\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n          isSource: true,\r\n          isDestination: false,\r\n        });\r\n      } else if (gridOptions.isDestinationDragged) {\r\n        const [i, j] = gridOptions.destination;\r\n        gridOptions.matrix[i][j].update({\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n          isSource: false,\r\n          isDestination: true,\r\n        });\r\n      }\r\n      if (gridOptions.animationOnDrop) {\r\n        await gridOptions.chozenAlgorithmCallback();\r\n      }\r\n    }\r\n    gridOptions.clicked = false;\r\n    gridOptions.wpressed = false;\r\n    gridOptions.isSourceDragged = false;\r\n    gridOptions.isDestinationDragged = false;\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        onDragStart={(e) => {\r\n          e.preventDefault();\r\n        }}\r\n        className=\"grid\"\r\n        onMouseUp={handleMouseUp}\r\n        onMouseLeave={handleMouseLeave}\r\n      >\r\n        {rows}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","import gridOptions from \"../gridOptions\";\r\n\r\nexport async function runAlgorithm(name) {\r\n  if (!(name in searchingAlgorithms)) {\r\n    throw new ReferenceError(`Algorithm with name '${name}' is not defined`);\r\n  }\r\n  gridOptions.chozenAlgorithmCallback = searchingAlgorithms[name];\r\n  gridOptions.disableUserInteraction();\r\n  gridOptions.animationLaunched = true;\r\n  await searchingAlgorithms[name]();\r\n  gridOptions.animationLaunched = false;\r\n  gridOptions.enableUserInteraction();\r\n}\r\n\r\nexport const searchingAlgorithmsFullNames = {\r\n  bfs: \"Breadth First Search\",\r\n  dfs: \"Depth First Search\",\r\n  dijkstra: \"Dijkstra's Algorithm\",\r\n  astar: \"A* Algorithm\",\r\n};\r\n\r\nexport const animateCell = (state, i, j, time = gridOptions.delay) => {\r\n  return new Promise((resolve) => {\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      // when dragging either source or destination,update current cell immediately WITHOUT animation\r\n      gridOptions.matrix[i][j].update({\r\n        isSource: gridOptions.isSource(i, j),\r\n        isDestination: gridOptions.isDestination(i, j),\r\n        class: state,\r\n        weighted: gridOptions.isWeighted(i, j),\r\n      });\r\n      resolve();\r\n    } else {\r\n      setTimeout(() => {\r\n        gridOptions.matrix[i][j].update({\r\n          isSource: gridOptions.isSource(i, j),\r\n          isDestination: gridOptions.isDestination(i, j),\r\n          class: state,\r\n          weighted: gridOptions.isWeighted(i, j),\r\n        });\r\n        resolve();\r\n      }, time);\r\n    }\r\n  });\r\n};\r\n\r\nexport const searchingAlgorithms = {\r\n  bfs: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.clearPath();\r\n    const mat = gridOptions.matrix;\r\n    const n = mat.length;\r\n    const m = mat[0].length;\r\n    const visited = new Array(n).fill().map((e) => new Array(m).fill(false));\r\n    const isValid = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n    visited[src[0]][src[1]] = true;\r\n    const queue = [{ position: [...src], distance: 0, path: [] }];\r\n    const addends = [\r\n      [0, 1],\r\n      [1, 0],\r\n      [0, -1],\r\n      [-1, 0],\r\n    ];\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift();\r\n\r\n      const { position, distance, path } = current;\r\n      const [x, y] = position;\r\n      path.push([x, y]);\r\n\r\n      await animateCell(\"visited\", x, y);\r\n      visited[x][y] = true;\r\n\r\n      if (x === dst[0] && y === dst[1]) {\r\n        for (let [i, j] of path) {\r\n          await animateCell(\"path\", i, j);\r\n        }\r\n        break;\r\n      }\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (isValid(newX, newY)) {\r\n          if (\r\n            !visited[newX][newY] &&\r\n            !gridOptions.isWall(newX, newY)\r\n            // gridOptions.matrix[newX][newY].class !== 'wall'\r\n          ) {\r\n            visited[newX][newY] = true;\r\n            queue.push({\r\n              position: [newX, newY],\r\n              distance: distance + 1,\r\n              path: [...path, [newX, newY]],\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  dfs: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n\r\n    gridOptions.clearPath();\r\n    await animateCell(\"unvisited\", src[0], src[1]);\r\n    await animateCell(\"unvisited\", src[0], src[1]);\r\n    const visited = new Set();\r\n    let foundPath = [];\r\n    async function search(current, path) {\r\n      const [x, y] = current;\r\n      if (gridOptions.isWall(x, y) || visited.has(x + \",\" + y)) return false;\r\n      path.push([x, y]);\r\n      await animateCell(\"visited\", x, y);\r\n      visited.add(x + \",\" + y);\r\n      // if ()) return false;\r\n      if (x === dst[0] && y === dst[1]) {\r\n        foundPath = path;\r\n        return true;\r\n      }\r\n      const addends = [\r\n        [-1, 0],\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n      ];\r\n      const n = gridOptions.matrix.length;\r\n      const m = gridOptions.matrix[0].length;\r\n      const isValid = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (isValid(newX, newY)) {\r\n          let found = await search([newX, newY], [...path]);\r\n          if (found) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    await search(src, []);\r\n    for (let [i, j] of foundPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n  },\r\n  dijkstra: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.clearPath();\r\n    const matrix = gridOptions.matrix;\r\n    const n = matrix.length;\r\n    const m = matrix[0].length;\r\n    const unvisited = new Set();\r\n    const prev = new Array(n);\r\n    const distances = new Array(n);\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n      prev[i] = new Array(m).fill(null);\r\n      distances[i] = new Array(m).fill(Infinity);\r\n      for (let j = 0; j < m; ++j) {\r\n        unvisited.add(i + \",\" + j);\r\n      }\r\n    }\r\n\r\n    const stringify = (i, j) => i + \",\" + j;\r\n    const indexify = (vertex) => (vertex ? vertex.split(\",\").map((idx) => Number(idx)) : [-1, -1]);\r\n\r\n    const extractMin = () => {\r\n      // finds the vertex with minimum distance, removes it from the \"unvisited\" set and returns it\r\n      let minDistance = Infinity;\r\n      let minDistanceVertex = null;\r\n      const verticies = unvisited.keys();\r\n      for (let v of verticies) {\r\n        const [i, j] = indexify(v);\r\n        if (distances[i][j] < minDistance) {\r\n          minDistance = distances[i][j];\r\n          minDistanceVertex = v;\r\n        }\r\n      }\r\n      if (!minDistanceVertex) {\r\n        minDistanceVertex = verticies[0];\r\n      }\r\n\r\n      unvisited.delete(minDistanceVertex);\r\n      return indexify(minDistanceVertex);\r\n    };\r\n    const getNeighbors = (v) => {\r\n      const neighbors = [];\r\n      let [x, y] = v;\r\n\r\n      const addends = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n        [-1, 0],\r\n      ];\r\n\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && !gridOptions.isWall(newX, newY)) {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n\r\n      return neighbors;\r\n    };\r\n\r\n    distances[src[0]][src[1]] = 0;\r\n\r\n    while (unvisited.size > 0) {\r\n      const [x, y] = extractMin();\r\n      if (x === -1 || y === -1) {\r\n        // there is no path\r\n        break;\r\n      }\r\n      await animateCell(\"visited\", x, y);\r\n      if (x === dst[0] && y === dst[1]) {\r\n        // found the shortest path\r\n        break;\r\n      }\r\n      const neighbors = getNeighbors([x, y]);\r\n\r\n      for (let neighbor of neighbors) {\r\n        let [i, j] = neighbor;\r\n\r\n        let v = stringify(i, j);\r\n        if (unvisited.has(v)) {\r\n          const alt = distances[x][y] + (matrix[i][j].weighted ? 5 : 1);\r\n\r\n          if (alt < distances[i][j]) {\r\n            distances[i][j] = alt;\r\n            prev[i][j] = [x, y];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let shortestPath = [];\r\n    if (prev[dst[0]][dst[1]]) {\r\n      let current = dst;\r\n      while (current) {\r\n        shortestPath.push(current);\r\n        current = prev[current[0]][current[1]];\r\n      }\r\n    }\r\n\r\n    shortestPath.reverse();\r\n    for (let [i, j] of shortestPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n  },\r\n\r\n  astar: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.disableUserInteraction();\r\n    gridOptions.clearPath();\r\n    const matrix = gridOptions.matrix;\r\n    const n = matrix.length;\r\n    const m = matrix[0].length;\r\n\r\n    const openSet = new Set();\r\n    const prev = new Array(n);\r\n    const gScore = new Array(n);\r\n    const fScore = new Array(n);\r\n\r\n    const getHeruistic = (i, j) => {\r\n      return Math.abs(i - dst[0]) + Math.abs(j - dst[1]);\r\n    };\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n      gScore[i] = new Array(m).fill(Infinity);\r\n      fScore[i] = new Array(m).fill(Infinity);\r\n      prev[i] = new Array(m);\r\n      for (let j = 0; j < m; ++j) {\r\n        prev[i][j] = null;\r\n      }\r\n    }\r\n\r\n    fScore[src[0]][src[1]] = getHeruistic(src[0], src[1]);\r\n    openSet.add(src[0] + \",\" + src[1]);\r\n    gScore[src[0]][src[1]] = 0;\r\n\r\n    const stringify = (i, j) => i + \",\" + j; // returns hash value for two indicies of the vertex\r\n    const indexify = (vertex) => vertex.split(\",\").map((idx) => Number(idx)); // returns two indicies from hash value of the vertex\r\n\r\n    const extractMin = () => {\r\n      // finds the vertex with minimum distance, removes it from the \"openSet\" and returns it\r\n      let minFScore = Infinity;\r\n      let minFScoreVertex = null;\r\n      const verticies = openSet.keys();\r\n\r\n      // find the vertex in openSet with minimum fScore\r\n      for (let v of verticies) {\r\n        const [i, j] = indexify(v);\r\n\r\n        if (fScore[i][j] < minFScore) {\r\n          minFScore = fScore[i][j];\r\n          minFScoreVertex = v;\r\n        } else if (fScore[i][j] === minFScore) {\r\n          // if fscores are equal, choose a vertex with lower herustic score\r\n          let [x, y] = indexify(minFScoreVertex);\r\n          if (getHeruistic(i, j) < getHeruistic(x, y)) {\r\n            minFScore = fScore[i][j];\r\n            minFScoreVertex = v;\r\n          }\r\n        }\r\n      }\r\n\r\n      openSet.delete(minFScoreVertex);\r\n      return indexify(minFScoreVertex);\r\n    };\r\n\r\n    const getNeighbors = (v) => {\r\n      const neighbors = [];\r\n      let [x, y] = v;\r\n\r\n      // addendsd for possible directions we can move from v\r\n      const addends = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n        [-1, 0],\r\n      ];\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n\r\n        // validating possible neighbor coordinates\r\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && matrix[newX][newY].class !== \"wall\") {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n      return neighbors;\r\n    };\r\n\r\n    while (openSet.size > 0) {\r\n      const [x, y] = extractMin(); // extract the node with minimal fScore in openSet and remove it from the set\r\n\r\n      await animateCell(\"visited\", x, y);\r\n\r\n      if (x === dst[0] && y === dst[1]) {\r\n        // prev[x][y].push([x, y]);\r\n        break;\r\n      }\r\n      const neighbors = getNeighbors([x, y]);\r\n\r\n      for (let neighbor of neighbors) {\r\n        let [i, j] = neighbor;\r\n        const tentative_gScore = gScore[x][y] + (matrix[i][j].weighted ? 5 : 1);\r\n\r\n        // await sleepPromise('visited', i, j);\r\n        if (tentative_gScore < gScore[i][j]) {\r\n          gScore[i][j] = tentative_gScore;\r\n          prev[i][j] = [x, y];\r\n          fScore[i][j] = tentative_gScore + getHeruistic(i, j);\r\n          openSet.add(stringify(i, j));\r\n        }\r\n      }\r\n    }\r\n    const shortestPath = [];\r\n\r\n    if (prev[dst[0]][dst[1]]) {\r\n      // if the path found, than construct the shortestPath via backtracking from the destination node\r\n      let currentNode = dst;\r\n      while (currentNode) {\r\n        shortestPath.push(currentNode);\r\n        currentNode = prev[currentNode[0]][currentNode[1]];\r\n      }\r\n    }\r\n\r\n    shortestPath.reverse(); // reversing the path to get it in right order (from source to destination)\r\n\r\n    for (let [i, j] of shortestPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n    gridOptions.enableUserInteraction();\r\n  },\r\n};\r\n","import React from \"react\";\r\nimport { runAlgorithm, searchingAlgorithmsFullNames } from \"../Algorithms/searchingAlgorithms\";\r\n\r\nconst SearchingAlgorithmButton = ({ algorithmName }) => {\r\n  const handleClick = async () => {\r\n    await runAlgorithm(algorithmName);\r\n  };\r\n  return <button onClick={handleClick}>{searchingAlgorithmsFullNames[algorithmName]}</button>;\r\n};\r\n\r\nexport default SearchingAlgorithmButton;\r\n","import gridOptions from \"../gridOptions\";\r\n\r\nconst animateCell = (state, i, j, time = gridOptions.delay) => {\r\n  return new Promise((resolve) => {\r\n    if (state === \"wall\" && (gridOptions.isSource(i, j) || gridOptions.isDestination(i, j))) {\r\n      resolve();\r\n    } else {\r\n      setTimeout(() => {\r\n        gridOptions.matrix[i][j].update({\r\n          isSource: gridOptions.isSource(i, j),\r\n          isDestination: gridOptions.isDestination(i, j),\r\n          class: state,\r\n          weighted: gridOptions.isWeighted(i, j),\r\n        });\r\n        resolve();\r\n      }, time);\r\n    }\r\n  });\r\n};\r\n\r\nexport async function runMazeAlgorithm(name) {\r\n  if (!(name in mazeAlgorithms)) {\r\n    throw new ReferenceError(`Algorithm with name '${name}' is not defined`);\r\n  }\r\n  gridOptions.clearBoard();\r\n  gridOptions.disableUserInteraction();\r\n  gridOptions.animationLaunched = true;\r\n  await mazeAlgorithms[name]();\r\n  gridOptions.animationLaunched = false;\r\n  gridOptions.enableUserInteraction();\r\n}\r\n\r\nexport const mazeAlgorithmsFullNames = {\r\n  recursiveDivision: \"Recursive Division\",\r\n  randomizedDFS: \"Randomized DFS\",\r\n  binaryTree: \"Binary Tree\",\r\n  primsRandomized: \"Prim's randomized\",\r\n  kruskalsRandomized: \"Kruskal's randomized\",\r\n};\r\n\r\nconst mazeAlgorithms = {\r\n  recursiveDivision: async () => {\r\n    const randInt = (min, max) => {\r\n      return Math.floor(Math.random() * (max - min + 1) + min);\r\n    };\r\n\r\n    const chooseOrientation = (height, width) => {\r\n      let orientation = \"\";\r\n      if (height > width) {\r\n        orientation = \"Horizontal\";\r\n      } else if (height < width) {\r\n        orientation = \"Vertical\";\r\n      } else {\r\n        orientation = Math.random() <= 0.5 ? \"Horizontal\" : \"Vertical\";\r\n      }\r\n      return orientation;\r\n    };\r\n    const randWallIndex = (from, to) => {\r\n      let wallIndex = -1;\r\n      const indicies = [];\r\n      for (let idx = from; idx <= to; ++idx) {\r\n        if (idx % 2 !== 0) indicies.push(idx);\r\n      }\r\n      if (indicies.length > 0) {\r\n        let randIndex = randInt(0, indicies.length - 1);\r\n        wallIndex = indicies[randIndex];\r\n        // wallIndex = indicies[Math.floor(indicies.length / 2)];\r\n      }\r\n\r\n      return wallIndex;\r\n    };\r\n\r\n    const randHoleIndex = (from, to) => {\r\n      let holeIndex = -1;\r\n\r\n      const indicies = [];\r\n\r\n      for (let col = from; col <= to; ++col) {\r\n        if (col % 2 === 0) indicies.push(col);\r\n      }\r\n      if (indicies.length > 0) {\r\n        let randIndex = randInt(0, indicies.length - 1);\r\n        holeIndex = indicies[randIndex];\r\n        // holeIndex = indicies[Math.floor(indicies.length / 2)];\r\n      }\r\n\r\n      return holeIndex;\r\n    };\r\n\r\n    const divide = async (i, height, j, width) => {\r\n      if (width <= 2 || height <= 2) {\r\n        return;\r\n      }\r\n\r\n      const orientation = chooseOrientation(height, width);\r\n\r\n      if (orientation === \"Horizontal\") {\r\n        const wallIndex = randWallIndex(i + 1, i + height - 2);\r\n        if (wallIndex === -1) return;\r\n\r\n        const holeIndex = randHoleIndex(j, j + width - 1);\r\n        if (holeIndex === -1) return;\r\n\r\n        for (let col = j; col < j + width; ++col) {\r\n          if (col !== holeIndex) {\r\n            await animateCell(\"wall\", wallIndex, col);\r\n          }\r\n        }\r\n\r\n        await divide(i, wallIndex - i, j, width);\r\n        await divide(wallIndex + 1, i + height - wallIndex - 1, j, width);\r\n      } else if (orientation === \"Vertical\") {\r\n        let wallIndex = randWallIndex(j + 1, j + width - 2);\r\n        if (wallIndex === -1) return;\r\n\r\n        const holeIndex = randHoleIndex(i, i + height - 1);\r\n        if (holeIndex === -1) return;\r\n        for (let row = i; row < i + height; ++row) {\r\n          if (row !== holeIndex) {\r\n            await animateCell(\"wall\", row, wallIndex);\r\n          }\r\n        }\r\n        await divide(i, height, j, wallIndex - j);\r\n        await divide(i, height, wallIndex + 1, j + width - wallIndex - 1);\r\n      }\r\n    };\r\n    const [n, m] = gridOptions.getSize();\r\n    await divide(0, n, 0, m);\r\n\r\n    // check if source or destination are disconnected from the grid (are surrounded by walls),\r\n    //    if so, randomly remove one of the walls\r\n\r\n    const src = gridOptions.source;\r\n    const sourceNeighbors = [\r\n      [src[0] + 1, src[1]],\r\n      [src[0] - 1, src[1]],\r\n      [src[0], src[1] + 1],\r\n      [src[0], src[1] - 1],\r\n    ].filter(([i, j]) => i >= 0 && j >= 0 && i < n && j < m);\r\n\r\n    if (sourceNeighbors.every(([i, j]) => gridOptions.isWall(i, j))) {\r\n      const randIndex = randInt(0, sourceNeighbors.length - 1);\r\n      await animateCell(\"unvisited\", ...sourceNeighbors[randIndex]);\r\n    }\r\n\r\n    const dst = gridOptions.destination;\r\n    const destinationNeighbors = [\r\n      [dst[0] + 1, dst[1]],\r\n      [dst[0] - 1, dst[1]],\r\n      [dst[0], dst[1] + 1],\r\n      [dst[0], dst[1] - 1],\r\n    ].filter(([i, j]) => i >= 0 && j >= 0 && i < n && j < m);\r\n\r\n    if (destinationNeighbors.every(([i, j]) => gridOptions.isWall(i, j))) {\r\n      const randIndex = randInt(0, destinationNeighbors.length - 1);\r\n      await animateCell(\"unvisited\", ...destinationNeighbors[randIndex]);\r\n    }\r\n  },\r\n  randomizedDFS: async () => {\r\n    const [n, m] = gridOptions.getSize();\r\n    let visited = new Set();\r\n\r\n    const stringify = ([x, y]) => x + \",\" + y;\r\n    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\r\n\r\n    const isVisited = ([x, y]) => {\r\n      return visited.has(x + \",\" + y);\r\n    };\r\n\r\n    const getNeigborsWithDistance = (x, y, distance) => {\r\n      const neighbors = [];\r\n      let addends = [\r\n        [0, distance],\r\n        [distance, 0],\r\n        [0, -distance],\r\n        [-distance, 0],\r\n      ];\r\n\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m) {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n      // randomly shuffle with FisherYates algorithm\r\n      const shuffled = [];\r\n      while (neighbors.length > 0) {\r\n        const l = neighbors.length - 1;\r\n        let randIndex = randInt(0, l);\r\n        shuffled.push(neighbors[randIndex]);\r\n\r\n        const temp = neighbors[randIndex];\r\n        neighbors[randIndex] = neighbors[l];\r\n        neighbors[l] = temp;\r\n\r\n        neighbors.pop();\r\n      }\r\n\r\n      return shuffled;\r\n    };\r\n\r\n    const getNeigbors = (x, y) => {\r\n      return getNeigborsWithDistance(x, y, 2);\r\n    };\r\n\r\n    const getHoleNeighbors = (x, y) => {\r\n      return getNeigborsWithDistance(x, y, 1);\r\n    };\r\n\r\n    const dfs = async (vertex) => {\r\n      const [i, j] = vertex;\r\n      if (isVisited(vertex)) return;\r\n\r\n      visited.add(stringify(vertex));\r\n\r\n      const neighbors = getNeigbors(i, j);\r\n      for (let neighbor of neighbors) {\r\n        if (!isVisited(neighbor)) {\r\n          const wallI = (i + neighbor[0]) / 2;\r\n          const wallJ = (j + neighbor[1]) / 2;\r\n          if (!gridOptions.isWall(wallI, wallJ)) await animateCell(\"wall\", wallI, wallJ);\r\n          if (i === wallI) {\r\n            wallI - 1 >= 0 && !gridOptions.isWall(wallI - 1, wallJ) && (await animateCell(\"wall\", wallI - 1, wallJ));\r\n            wallI + 1 < n && !gridOptions.isWall(wallI + 1, wallJ) && (await animateCell(\"wall\", wallI + 1, wallJ));\r\n          } else if (j === wallJ) {\r\n            wallJ - 1 >= 0 && !gridOptions.isWall(wallI, wallJ - 1) && (await animateCell(\"wall\", wallI, wallJ - 1));\r\n            wallJ + 1 < m && !gridOptions.isWall(wallI, wallJ + 1) && (await animateCell(\"wall\", wallI, wallJ + 1));\r\n          }\r\n        }\r\n      }\r\n      for (let neighbor of neighbors) {\r\n        if (!isVisited(neighbor)) {\r\n          const holeI = (i + neighbor[0]) / 2;\r\n          const holeJ = (j + neighbor[1]) / 2;\r\n\r\n          const holeNeighbors = getHoleNeighbors(holeI, holeJ);\r\n          for (let holeNeighbor of holeNeighbors) {\r\n            if (\r\n              !gridOptions.isWall(holeNeighbor[0], holeNeighbor[1]) &&\r\n              !isVisited(holeNeighbor) &&\r\n              (neighbor[0] !== holeNeighbor[0] || neighbor[1] !== holeNeighbor[1])\r\n            ) {\r\n              await animateCell(\"wall\", holeNeighbor[0], holeNeighbor[1]);\r\n            }\r\n          }\r\n          await animateCell(\"unvisited\", holeI, holeJ, 0);\r\n          visited.add(stringify([holeI, holeJ]));\r\n          await dfs(neighbor);\r\n        }\r\n      }\r\n    };\r\n\r\n    await dfs([0, 0]);\r\n\r\n    // adding walls to unreachable cells (which are considered to be walls)\r\n    // for (let i = 1; i < n; i += 2) {\r\n    //   for (let j = 1; j < m; j += 2) {\r\n    //     if (\r\n    //       gridOptions.isUnvisited(i, j) &&\r\n    //       getHoleNeighbors(i, j).every(([row, col]) => {\r\n    //         return gridOptions.isWall(row, col);\r\n    //       })\r\n    //     ) {\r\n    //       await animateCell(\"wall\", i, j);\r\n    //     }\r\n    //   }\r\n    // }\r\n  },\r\n\r\n  binaryTree: async () => {\r\n    const [n, m] = gridOptions.getSize();\r\n    for (let i = 2; i < n; i += 2) {\r\n      for (let j = 2; j < m; j += 2) {\r\n        await animateCell(\"unvisited\", i, j);\r\n        // randomly chooze connection direciton either north or west\r\n        if (Math.random() <= 0.5) {\r\n          const passageI = i - 1;\r\n          const passageJ = j;\r\n          if (passageI < n && passageJ < m) {\r\n            await animateCell(\"wall\", i, passageJ - 1);\r\n            await animateCell(\"wall\", passageI, passageJ - 1);\r\n          }\r\n        } else {\r\n          const passageI = i;\r\n          const passageJ = j - 1;\r\n          if (passageI >= 1 && passageI < n && passageJ >= 0 && passageJ < m) {\r\n            await animateCell(\"wall\", passageI - 1, j);\r\n            await animateCell(\"wall\", passageI - 1, passageJ);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n  primsRandomized: async () => {\r\n    const [n, m] = gridOptions.getSize();\r\n    const visited = new Set();\r\n    const unvisited = new Set();\r\n    const middleRow = Math.floor(n / 2) - (Math.floor(n / 2) % 2);\r\n    const middleCol = Math.floor(m / 2) - (Math.floor(m / 2) % 2);\r\n    unvisited.add(`${middleRow},${middleCol}`);\r\n\r\n    const randInt = (min, max) => {\r\n      return Math.floor(Math.random() * (max - min + 1) + min);\r\n    };\r\n\r\n    const isVisited = (i, j) => visited.has(i + \",\" + j);\r\n\r\n    const extractRandomVertexFromUnvisitedSet = () => {\r\n      const randIndex = randInt(0, unvisited.size - 1);\r\n      const randVertex = Array.from(unvisited.keys())[randIndex];\r\n      unvisited.delete(randVertex);\r\n      return randVertex;\r\n    };\r\n    const getVisitedNeigbors = (i, j) => {\r\n      const neighbors = [\r\n        [i, j + 2],\r\n        [i + 2, j],\r\n        [i, j - 2],\r\n        [i - 2, j],\r\n      ];\r\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && isVisited(r, c));\r\n    };\r\n    const getWallNeighbors = (i, j) => {\r\n      const neighbors = [\r\n        [i, j + 1],\r\n        [i + 1, j],\r\n        [i, j - 1],\r\n        [i - 1, j],\r\n        [i + 1, j + 1],\r\n        [i + 1, j - 1],\r\n        [i - 1, j - 1],\r\n        [i - 1, j + 1],\r\n      ];\r\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && !isVisited(r, c));\r\n    };\r\n\r\n    const getUnvisitedNeigbors = (i, j) => {\r\n      const neighbors = [\r\n        [i, j + 2],\r\n        [i + 2, j],\r\n        [i, j - 2],\r\n        [i - 2, j],\r\n      ];\r\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && !isVisited(r, c));\r\n    };\r\n    while (unvisited.size > 0) {\r\n      const vertex = extractRandomVertexFromUnvisitedSet();\r\n      const [vi, vj] = vertex.split(\",\").map((e) => Number(e));\r\n      await animateCell(\"unvisited\", vi, vj, 0);\r\n      for (let [i, j] of getWallNeighbors(vi, vj)) {\r\n        if (!gridOptions.isWall(i, j)) await animateCell(\"wall\", i, j);\r\n      }\r\n      visited.add(vertex);\r\n      const visitedNeigbors = getVisitedNeigbors(vi, vj);\r\n      if (visitedNeigbors.length > 0) {\r\n        const randIndex = randInt(0, visitedNeigbors.length - 1);\r\n        const randVertex = visitedNeigbors[randIndex];\r\n        await Promise.all([\r\n          animateCell(\"unvisited\", randVertex[0], randVertex[1], 0),\r\n          animateCell(\"unvisited\", (randVertex[0] + vi) / 2, (randVertex[1] + vj) / 2, 0),\r\n        ]);\r\n      }\r\n\r\n      const unvisitedNeigbors = getUnvisitedNeigbors(vi, vj);\r\n      unvisitedNeigbors.forEach(([i, j]) => {\r\n        unvisited.add(i + \",\" + j);\r\n      });\r\n    }\r\n  },\r\n  kruskalsRandomized: async () => {\r\n    const [n, m] = gridOptions.getSize();\r\n\r\n    const isValidVertex = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n\r\n    const getAllPossibleNeighbors = (i, j) => {\r\n      const neighbors = [\r\n        [i, j + 2],\r\n        [i + 2, j],\r\n        [i, j - 2],\r\n        [i - 2, j],\r\n      ];\r\n      return neighbors.filter(([x, y]) => isValidVertex(x, y));\r\n    };\r\n    const visitedVertices = new Set();\r\n    const unvisitedEdges = new Set();\r\n    for (let i = 0; i < n; i += 2) {\r\n      for (let j = 0; j < m; j += 2) {\r\n        const possibleNeigbors = getAllPossibleNeighbors(i, j);\r\n        for (let [x, y] of possibleNeigbors) {\r\n          const edge = `${Math.min(i, x)},${Math.min(j, y)}-${Math.max(i, x)},${Math.max(j, y)}`; // sorted\r\n          unvisitedEdges.add(edge);\r\n        }\r\n      }\r\n    }\r\n    const randInt = (min, max) => {\r\n      return Math.floor(Math.random() * (max - min + 1) + min);\r\n    };\r\n\r\n    const extractRandomEdgeFromUnvisitedEdgesSet = () => {\r\n      const randIndex = randInt(0, unvisitedEdges.size - 1);\r\n      const randVertex = Array.from(unvisitedEdges.keys())[randIndex];\r\n      unvisitedEdges.delete(randVertex);\r\n      return randVertex;\r\n    };\r\n\r\n    const addSurroundingWallsToEdge = async (edge) => {\r\n      const [v1, v2] = edge.split(\"-\");\r\n      const [i1, j1] = v1.split(\",\").map((e) => Number(e));\r\n      const [i2, j2] = v2.split(\",\").map((e) => Number(e));\r\n\r\n      const vm = `${(i1 + i2) / 2},${(j1 + j2) / 2}`; // the vertex between v1 and v2\r\n\r\n      for (let i = i1 - 1; i <= i2 + 1; i++) {\r\n        for (let j = j1 - 1; j <= j2 + 1; j++) {\r\n          const wall = `${i},${j}`;\r\n          if (\r\n            isValidVertex(i, j) &&\r\n            ![v1, v2, vm].includes(wall) &&\r\n            !visitedVertices.has(wall) &&\r\n            !gridOptions.isWall(i, j)\r\n          ) {\r\n            await animateCell(\"wall\", i, j);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    const adj = {};\r\n\r\n    const areConnected = (v1, v2) => {\r\n      let curr = null;\r\n      let stack = [v1];\r\n      const visited = new Set();\r\n      while (stack.length) {\r\n        curr = stack.pop();\r\n        visited.add(curr);\r\n        if (curr === v2) return true;\r\n        for (let neighbor of adj[curr] || []) {\r\n          if (!visited.has(neighbor)) {\r\n            stack.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    while (unvisitedEdges.size > 0) {\r\n      const edge = extractRandomEdgeFromUnvisitedEdgesSet();\r\n\r\n      await addSurroundingWallsToEdge(edge);\r\n\r\n      const [v1, v2] = edge.split(\"-\");\r\n      const [i1, j1] = v1.split(\",\").map((e) => Number(e));\r\n      const [i2, j2] = v2.split(\",\").map((e) => Number(e));\r\n\r\n      const vm = `${(i1 + i2) / 2},${(j1 + j2) / 2}`; // the vertex between v1 and v2\r\n      const [im, jm] = vm.split(\",\").map((e) => Number(e));\r\n      if (!areConnected(v1, v2)) {\r\n        await Promise.all([\r\n          animateCell(\"unvisited\", i1, j1, 0),\r\n          animateCell(\"unvisited\", i2, j2, 0),\r\n          animateCell(\"unvisited\", im, jm, 0),\r\n        ]);\r\n        visitedVertices.add(v1);\r\n        visitedVertices.add(v2);\r\n        visitedVertices.add(vm);\r\n        if (!adj[v1]) adj[v1] = [];\r\n        if (!adj[v2]) adj[v2] = [];\r\n        adj[v1].push(v2);\r\n        adj[v2].push(v1);\r\n      }\r\n    }\r\n  },\r\n};\r\n","import React from \"react\";\r\nimport { runMazeAlgorithm, mazeAlgorithmsFullNames } from \"../Algorithms/mazeAlgorithms\";\r\n\r\nconst MazeAlgorithmButton = ({ algorithmName }) => {\r\n  const handleClick = async () => {\r\n    await runMazeAlgorithm(algorithmName);\r\n  };\r\n  return <button onClick={handleClick}>{mazeAlgorithmsFullNames[algorithmName]}</button>;\r\n};\r\n\r\nexport default MazeAlgorithmButton;\r\n","import React, { useEffect, useRef } from \"react\";\r\nimport SearchingAlgorithmButton from \"./SearchingAlgorithmButton\";\r\nimport MazeAlgorithmButton from \"./MazeAlgorithmButton\";\r\n\r\nimport gridOptions from \"../gridOptions\";\r\n\r\nimport sourceIcon from \"../Assets/Icons/source.png\";\r\nimport destinationIcon from \"../Assets/Icons/destination.png\";\r\nimport wallIcon from \"../Assets/Icons/wall.png\";\r\nimport weightIcon from \"../Assets/Icons/weight.png\";\r\nimport unvisitedIcon from \"../Assets/Icons/unvisited.png\";\r\nimport visitedIcon from \"../Assets/Icons/visited.png\";\r\nimport pathIcon from \"../Assets/Icons/path.png\";\r\nimport \"../Assets/Styles/controlPanel.css\";\r\n\r\nconst ControlPanel = () => {\r\n  const speedInput = useRef(null);\r\n  const isAnimatedCheckBox = useRef(null);\r\n  const anmationOnDrop = useRef(null);\r\n  useEffect(() => {\r\n    speedInput.current.value = 200;\r\n    isAnimatedCheckBox.current.checked = true;\r\n    anmationOnDrop.current.checked = true;\r\n    gridOptions.delay = 0;\r\n\r\n    const handleWDown = (e) => {\r\n      if (e.key === \"w\") {\r\n        gridOptions.wpressed = true;\r\n      }\r\n    };\r\n    const handleWUp = (e) => {\r\n      if (e.key === \"w\") {\r\n        gridOptions.wpressed = false;\r\n      }\r\n    };\r\n    window.addEventListener(\"keydown\", handleWDown);\r\n    window.addEventListener(\"keyup\", handleWUp);\r\n\r\n    return function cleanUp() {\r\n      window.removeEventListener(handleWDown);\r\n      window.removeEventListener(handleWUp);\r\n    };\r\n  }, []);\r\n  return (\r\n    <div className=\"controlPanel\">\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Searching Algorithms</label>\r\n        <SearchingAlgorithmButton algorithmName={\"bfs\"} />\r\n        <SearchingAlgorithmButton algorithmName={\"dfs\"} />\r\n        <SearchingAlgorithmButton algorithmName={\"dijkstra\"} />\r\n        <SearchingAlgorithmButton algorithmName={\"astar\"} />\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Maze Algorithms</label>\r\n        <MazeAlgorithmButton algorithmName={\"recursiveDivision\"} />\r\n        <MazeAlgorithmButton algorithmName={\"randomizedDFS\"} />\r\n        <MazeAlgorithmButton algorithmName={\"binaryTree\"} />\r\n        <MazeAlgorithmButton algorithmName={\"primsRandomized\"} />\r\n        <MazeAlgorithmButton algorithmName={\"kruskalsRandomized\"} />\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Grid options</label>\r\n        <button\r\n          onClick={async () => {\r\n            gridOptions.clearBoard();\r\n          }}\r\n        >\r\n          Clear Board\r\n        </button>\r\n        <button\r\n          onClick={async () => {\r\n            gridOptions.clearPath();\r\n          }}\r\n        >\r\n          Clear Path\r\n        </button>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"speedInput\">Speed:</label>\r\n          <input\r\n            ref={speedInput}\r\n            type=\"range\"\r\n            min=\"0\"\r\n            max=\"200\"\r\n            onChange={(e) => {\r\n              gridOptions.delay = 200 - Number(e.target.value);\r\n            }}\r\n          />\r\n        </div>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"isAnimatedCheckBox\">Animated: </label>\r\n          <input\r\n            onChange={() => {\r\n              gridOptions.isAnimated = !gridOptions.isAnimated;\r\n            }}\r\n            ref={isAnimatedCheckBox}\r\n            type=\"checkbox\"\r\n          />\r\n        </div>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"anmationOnDrop\">Animation on drop: </label>\r\n          <input\r\n            onChange={() => {\r\n              gridOptions.animationOnDrop = !gridOptions.animationOnDrop;\r\n            }}\r\n            ref={anmationOnDrop}\r\n            type=\"checkbox\"\r\n          />\r\n        </div>\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Icons</label>\r\n        <div className=\"inline-block\">\r\n          <img src={sourceIcon} alt=\"destination.png\" />\r\n          <label>Source node</label>\r\n          <img src={destinationIcon} alt=\"source.png\" />\r\n          <label>Destination node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={wallIcon} alt=\"wall.png\" />\r\n          <label>Wall node</label>\r\n          <img src={weightIcon} alt=\"source.png\" />\r\n          <label>Weighted node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={unvisitedIcon} alt=\"unvisited.png\" />\r\n          <label>Unvisited node</label>\r\n          <img src={visitedIcon} alt=\"visited.png\" />\r\n          <label>Visited node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={pathIcon} alt=\"path.png\" />\r\n          <label>Path node</label>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ControlPanel;\r\n","import React, { useEffect } from \"react\";\r\nimport Grid from \"./Grid\";\r\nimport ControlPanel from \"./ControlPanel\";\r\nimport \"../Assets/Styles/app.css\";\r\n\r\nconst App = () => {\r\n  useEffect(() => {\r\n    document.title = \"Pathfinding & Maze Generating visualizer\";\r\n  }, []);\r\n  return (\r\n    <div className=\"flex-box\">\r\n      <ControlPanel />\r\n      <Grid rowCount={25} columnCount={55} startNodePosition={[11, 10]} endNodePosition={[11, 40]} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport App from \"./Components/App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}
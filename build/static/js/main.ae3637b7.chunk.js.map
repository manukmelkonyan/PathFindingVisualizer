{"version":3,"sources":["Assets/Icons/source.png","Assets/Icons/destination.png","Assets/Icons/wall.png","Assets/Icons/weight.png","Assets/Icons/unvisited.png","Assets/Icons/visited.png","Assets/Icons/path.png","gridOptions.js","Components/Cell.js","Components/Row.js","Components/Grid.js","Algorithms/searchingAlgorithms.js","Components/SearchingAlgorithmButton.js","Algorithms/mazeAlgorithms.js","Components/MazeAlgorithmButton.js","Components/ControlPanel.js","Components/App.js","index.js"],"names":["module","exports","gridOptions","disableUserInteraction","document","querySelectorAll","forEach","elem","disabled","enableUserInteraction","animationLaunched","animationOnDrop","isAnimated","source","destination","isSourceDragged","isDestinationDragged","chozenAlgorithmCallback","async","matrix","delay","clicked","wpressed","sourceDragged","destinationDragged","getSize","this","length","isSource","i","j","isDestination","isUnvisited","includes","class","isWall","isWeighted","weighted","isVisited","isPath","clearPath","row","cell","update","_objectSpread","clearBoard","Cell","_ref","position","options","setOptions","useState","classList","concat","React","createElement","id","onDragStart","e","preventDefault","className","onMouseDown","button","onMouseOver","prevSource_i","prevSource_j","prevSourceOptions","prevDestination_i","prevDestination_j","prevDestinationOptions","Row","columnCount","cells","Array","fill","map","_","key","Grid","rowCount","startNodePosition","endNodePosition","rows","toString","start_i","start_j","end_i","end_j","Fragment","onMouseUp","onMouseLeave","searchingAlgorithmsFullNames","bfs","dfs","dijkstra","astar","animateCell","state","time","arguments","undefined","Promise","resolve","setTimeout","searchingAlgorithms","src","dst","mat","n","m","visited","isValid","queue","distance","path","addends","current","shift","x","y","push","newX","newY","Set","foundPath","search","has","add","unvisited","prev","distances","Infinity","stringify","indexify","vertex","split","idx","Number","extractMin","minDistance","minDistanceVertex","verticies","keys","v","delete","getNeighbors","neighbors","size","neighbor","alt","shortestPath","reverse","openSet","gScore","fScore","getHeruistic","Math","abs","minFScore","minFScoreVertex","tentative_gScore","currentNode","SearchingAlgorithmButton","algorithmName","onClick","name","ReferenceError","runAlgorithm","mazeAlgorithmsFullNames","recursiveDivision","randomizedDFS","binaryTree","primsRandomized","kruskalsRandomized","mazeAlgorithms","randInt","min","max","floor","random","randWallIndex","from","to","wallIndex","indicies","randHoleIndex","holeIndex","col","divide","height","width","orientation","chooseOrientation","sourceNeighbors","filter","every","_ref2","randIndex","destinationNeighbors","_ref3","_ref4","_ref5","_ref6","getNeigborsWithDistance","shuffled","l","temp","pop","getHoleNeighbors","wallI","wallJ","holeI","holeJ","holeNeighbors","holeNeighbor","passageI","passageJ","middleRow","middleCol","extractRandomVertexFromUnvisitedSet","randVertex","getWallNeighbors","_ref8","r","c","getUnvisitedNeigbors","_ref9","vi","vj","visitedNeigbors","_ref7","all","_ref0","getVisitedNeigbors","isValidVertex","getAllPossibleNeighbors","_ref1","visitedVertices","unvisitedEdges","possibleNeigbors","edge","extractRandomEdgeFromUnvisitedEdgesSet","addSurroundingWallsToEdge","v1","v2","i1","j1","i2","j2","vm","wall","adj","areConnected","curr","stack","im","jm","MazeAlgorithmButton","runMazeAlgorithm","ControlPanel","speedInput","useRef","isAnimatedCheckBox","anmationOnDrop","useEffect","value","checked","handleWDown","handleWUp","window","addEventListener","removeEventListener","htmlFor","ref","type","onChange","target","sourceIcon","destinationIcon","wallIcon","weightIcon","unvisitedIcon","visitedIcon","pathIcon","App","title","ReactDOM","render","getElementById"],"mappings":"iFAAAA,EAAOC,QAAU,85E,cCAjBD,EAAOC,QAAU,0lB,cCAjBD,EAAOC,QAAU,8hB,cCAjBD,EAAOC,QAAU,8/F,cCAjBD,EAAOC,QAAU,k3B,cCAjBD,EAAOC,QAAU,84B,cCAjBD,EAAOC,QAAU,0hB,8MCwEFC,MAxEK,CAClBC,uBAAwB,WACtBC,SAASC,iBAAiB,wBAAwBC,QAASC,GAAUA,EAAKC,UAAW,IAEvFC,sBAAuB,WACrBL,SAASC,iBAAiB,wBAAwBC,QAASC,GAAUA,EAAKC,UAAW,IAEvFE,mBAAmB,EACnBC,iBAAiB,EACjBC,YAAY,EACZC,OAAQ,GACRC,YAAa,GACbC,iBAAiB,EACjBC,sBAAsB,EACtBC,wBAAyBC,YACzBC,OAAQ,KACRC,MAAO,EACPC,SAAS,EACTC,UAAU,EACVC,eAAe,EACfC,oBAAoB,EACpBC,QAAS,WACP,MAAO,CAACC,KAAKP,OAAOQ,OAAQD,KAAKP,OAAO,GAAGQ,SAE7CC,SAAU,SAAUC,EAAGC,GACrB,OAAOJ,KAAKP,OAAOU,GAAGC,GAAGF,UAE3BG,cAAe,SAAUF,EAAGC,GAC1B,OAAOJ,KAAKP,OAAOU,GAAGC,GAAGC,eAE3BC,YAAa,SAAUH,EAAGC,GACxB,MAAO,CAAC,YAAa,sBAAsBG,SAASP,KAAKP,OAAOU,GAAGC,GAAGI,QAGxEC,OAAQ,SAAUN,EAAGC,GACnB,MAAO,CAAC,OAAQ,iBAAiBG,SAASP,KAAKP,OAAOU,GAAGC,GAAGI,QAE9DE,WAAY,SAAUP,EAAGC,GACvB,OAAOJ,KAAKP,OAAOU,GAAGC,GAAGO,UAE3BC,UAAW,SAAUT,EAAGC,GACtB,MAAO,CAAC,UAAW,oBAAoBG,SAASP,KAAKP,OAAOU,GAAGC,GAAGI,QAEpEK,OAAQ,SAAUV,EAAGC,GACnB,MAAO,CAAC,OAAQ,iBAAiBG,SAASP,KAAKP,OAAOU,GAAGC,GAAGI,QAE9DM,UAAW,WACT,IAAK,IAAIC,KAAOf,KAAKP,OACnB,IAAK,IAAIuB,KAAQD,EACX,CAAC,OAAQ,gBAAiB,UAAW,oBAAoBR,SAASS,EAAKR,QACzEQ,EAAKC,OAAMC,wBAAC,GACPF,GAAI,IACPR,MAAO,gBAOjBW,WAAY,WACV,IAAK,IAAIJ,KAAOf,KAAKP,OACnB,IAAK,IAAIuB,KAAQD,EACfC,EAAKC,OAAMC,wBAAC,GACPF,GAAI,IACPR,MAAO,YACPG,UAAU,O,MCiDLS,MA9GFC,IAA6B,IAA1BC,UAAU,EAAEnB,EAAC,EAAEC,IAAKiB,EAClC,MAAOE,EAASC,GAAcC,mBAAS,CACrCjB,MAAOhC,EAAYiB,OAAOU,GAAGC,GAAGI,MAChCG,SAAUnC,EAAYiB,OAAOU,GAAGC,GAAGO,SACnCT,SAAU1B,EAAYiB,OAAOU,GAAGC,GAAGF,SACnCG,cAAe7B,EAAYiB,OAAOU,GAAGC,GAAGC,gBAE1C7B,EAAYiB,OAAOU,GAAGC,GAAGa,OAASO,EAClChD,EAAYiB,OAAOU,GAAGC,GAAGI,MAAQe,EAAQf,MACzChC,EAAYiB,OAAOU,GAAGC,GAAGO,SAAWY,EAAQZ,SAC5CnC,EAAYiB,OAAOU,GAAGC,GAAGF,SAAWqB,EAAQrB,SAC5C1B,EAAYiB,OAAOU,GAAGC,GAAGC,cAAgBkB,EAAQlB,cAEjD,IAAIqB,EAAY,SAAWH,EAAQrB,SAAW,UAAY,KAAOqB,EAAQlB,cAAgB,eAAiB,IACtG7B,EAAYa,iBAAmBb,EAAYc,uBAAyBd,EAAYU,WAGlFwC,GAAaH,EAAQf,OAASe,EAAQZ,SAAW,WAAa,IAG9De,GAAa,GAAAC,OAAGJ,EAAQf,MAAK,eAAgBe,EAAQZ,SAAW,mBAAqB,IA6EvF,OACEiB,IAAAC,cAAA,OACEC,GAAI3B,EAAI,IAAMC,EACd2B,YAAcC,IACZA,EAAEC,kBAEJC,UAAWR,EACXS,YAjFqBH,IACN,IAAbA,EAAEI,QAAgB5D,EAAYQ,oBAElCR,EAAYmB,SAAU,EAElBnB,EAAYiB,OAAOU,GAAGC,GAAGF,SAC3B1B,EAAYa,iBAAkB,EACrBb,EAAYiB,OAAOU,GAAGC,GAAGC,cAClC7B,EAAYc,sBAAuB,EAE9Bd,EAAYoB,SAMNpB,EAAYoB,UACrB4B,EAAUN,wBAAC,GACNK,GAAO,IACVf,MAAO,YACPG,UAAWY,EAAQZ,YATrBa,EAAUN,wBAAC,GACNK,GAAO,IACVZ,UAAU,EACVH,MAAyB,SAAlBe,EAAQf,MAAmB,YAAc,YAoEpD6B,YAxDoB7C,UACtB,GAAKhB,EAAYmB,UAAWnB,EAAYiB,OAAOU,GAAGC,GAAGF,WAAY1B,EAAYiB,OAAOU,GAAGC,GAAGC,cAE1F,GAAI7B,EAAYa,gBAAiB,CAC/Bb,EAAYsC,YACZ,MAAOwB,EAAcC,GAAgB/D,EAAYW,OAC3CqD,EAAoBhE,EAAYiB,OAAO6C,GAAcC,GAE3D/D,EAAYiB,OAAO6C,GAAcC,GAActB,OAAMC,wBAAC,GACjDsB,GAAiB,IACpBtC,UAAU,KAEZ1B,EAAYW,OAAS,CAACgB,EAAGC,GAEzB5B,EAAYiB,OAAOU,GAAGC,GAAGa,OAAMC,wBAAC,GAC3BK,GAAO,IACVrB,UAAU,UAEP,GAAI1B,EAAYc,qBAAsB,CAC3Cd,EAAYsC,YACZ,MAAO2B,EAAmBC,GAAqBlE,EAAYY,YACrDuD,EAAyBnE,EAAYiB,OAAOgD,GAAmBC,GACrElE,EAAYiB,OAAOgD,GAAmBC,GAAmBzB,OAAMC,wBAAC,GAC3DyB,GAAsB,IACzBtC,eAAe,KAEjB7B,EAAYY,YAAc,CAACe,EAAGC,GAC9B5B,EAAYiB,OAAOU,GAAGC,GAAGa,OAAMC,wBAAC,GAC3BK,GAAO,IACVlB,eAAe,UAER7B,EAAYoB,SAErB4B,EAAUN,wBAAC,GACNK,GAAO,IACVf,MAAO,YACPG,UAAWY,EAAQZ,YAIrBa,EAAUN,wBAAC,GACNK,GAAO,IACVZ,UAAU,EACVH,MAAyB,SAAlBe,EAAQf,MAAmB,YAAc,c,MCrFzCoC,MAPHvB,IAAyB,IAAxB,EAAElB,EAAC,YAAE0C,GAAaxB,EAC7B,MAAMyB,EAAQ,IAAIC,MAAMF,GAAaG,OAAOC,IAAI,CAACC,EAAG9C,IAC3CwB,IAAAC,cAACT,EAAI,CAACE,SAAU,CAAEnB,IAAGC,KAAK+C,IAAKhD,EAAI,IAAMC,KAElD,OAAOwB,IAAAC,cAAA,OAAKK,UAAU,OAAOY,I,MC0FhBM,MA7FF/B,IAAoE,IAAnE,SAAEgC,EAAQ,YAAER,EAAW,kBAAES,EAAiB,gBAAEC,GAAiBlC,EACzE,MAAMmC,EAAO,IAAIT,MAAMM,GAAUL,OAAOC,IAAI,CAACC,EAAG/C,IAAMyB,IAAAC,cAACe,EAAG,CAACO,IAAKhD,EAAEsD,WAAYtD,EAAGA,EAAG0C,YAAaA,KACjGrE,EAAYiB,OAAS,IAAIsD,MAAMM,GAC/B,IAAK,IAAIlD,EAAI,EAAGA,EAAIkD,IAAYlD,EAAG,CACjC3B,EAAYiB,OAAOU,GAAK,IAAI4C,MAAMF,GAClC,IAAK,IAAIzC,EAAI,EAAGA,EAAIyC,IAAezC,EACjC5B,EAAYiB,OAAOU,GAAGC,GAAK,CAAEI,MAAO,YAAaG,UAAU,GAG/D,MAAO+C,EAASC,GAAWL,GACpBM,EAAOC,GAASN,EACvB/E,EAAYiB,OAAOiE,GAASC,GAASzD,UAAW,EAChD1B,EAAYiB,OAAOmE,GAAOC,GAAOxD,eAAgB,EACjD7B,EAAYW,OAAS,CAACuE,EAASC,GAC/BnF,EAAYY,YAAc,CAACwE,EAAOC,GA+DlC,OACEjC,IAAAC,cAAAD,IAAAkC,SAAA,KACElC,IAAAC,cAAA,OACEE,YAAcC,IACZA,EAAEC,kBAEJC,UAAU,OACV6B,UApEgBvE,UACpB,GAAiB,IAAbwC,EAAEI,OAAN,CACA,GAAI5D,EAAYa,iBAAmBb,EAAYc,qBAAsB,CAEnE,GADAd,EAAYsC,YACRtC,EAAYa,gBAAiB,CAC/B,MAAOc,EAAGC,GAAK5B,EAAYW,OAC3BX,EAAYiB,OAAOU,GAAGC,GAAGa,OAAO,CAC9BT,MAAO,YACPG,UAAU,EACVT,UAAU,EACVG,eAAe,SAEZ,GAAI7B,EAAYc,qBAAsB,CAC3C,MAAOa,EAAGC,GAAK5B,EAAYY,YAC3BZ,EAAYiB,OAAOU,GAAGC,GAAGa,OAAO,CAC9BT,MAAO,YACPG,UAAU,EACVT,UAAU,EACVG,eAAe,IAGf7B,EAAYS,uBACRT,EAAYe,0BAGtBf,EAAYa,iBAAkB,EAC9Bb,EAAYc,sBAAuB,EACnCd,EAAYmB,SAAU,EACtBnB,EAAYoB,UAAW,IAyCnBoE,aAtCmBxE,UACvB,GAAIhB,EAAYa,iBAAmBb,EAAYc,qBAAsB,CAEnE,GADAd,EAAYsC,YACRtC,EAAYa,gBAAiB,CAC/B,MAAOc,EAAGC,GAAK5B,EAAYW,OAC3BX,EAAYiB,OAAOU,GAAGC,GAAGa,OAAO,CAC9BT,MAAO,YACPG,UAAU,EACVT,UAAU,EACVG,eAAe,SAEZ,GAAI7B,EAAYc,qBAAsB,CAC3C,MAAOa,EAAGC,GAAK5B,EAAYY,YAC3BZ,EAAYiB,OAAOU,GAAGC,GAAGa,OAAO,CAC9BT,MAAO,YACPG,UAAU,EACVT,UAAU,EACVG,eAAe,IAGf7B,EAAYS,uBACRT,EAAYe,0BAGtBf,EAAYmB,SAAU,EACtBnB,EAAYoB,UAAW,EACvBpB,EAAYa,iBAAkB,EAC9Bb,EAAYc,sBAAuB,IAa9BkE,KC9EF,MAAMS,EAA+B,CAC1CC,IAAK,uBACLC,IAAK,qBACLC,SAAU,uBACVC,MAAO,gBAGIC,EAAc,SAACC,EAAOpE,EAAGC,GAAiC,IAA9BoE,EAAIC,UAAAxE,OAAA,QAAAyE,IAAAD,UAAA,GAAAA,UAAA,GAAGjG,EAAYkB,MAC1D,OAAO,IAAIiF,QAASC,IACdpG,EAAYa,iBAAmBb,EAAYc,sBAE7Cd,EAAYiB,OAAOU,GAAGC,GAAGa,OAAO,CAC9Bf,SAAU1B,EAAY0B,SAASC,EAAGC,GAClCC,cAAe7B,EAAY6B,cAAcF,EAAGC,GAC5CI,MAAO+D,EACP5D,SAAUnC,EAAYkC,WAAWP,EAAGC,KAEtCwE,KAEAC,WAAW,KACTrG,EAAYiB,OAAOU,GAAGC,GAAGa,OAAO,CAC9Bf,SAAU1B,EAAY0B,SAASC,EAAGC,GAClCC,cAAe7B,EAAY6B,cAAcF,EAAGC,GAC5CI,MAAO+D,EACP5D,SAAUnC,EAAYkC,WAAWP,EAAGC,KAEtCwE,KACCJ,MAKIM,EAAsB,CACjCZ,IAAK1E,UACH,MAAMuF,EAAMvG,EAAYW,OAClB6F,EAAMxG,EAAYY,YACxBZ,EAAYsC,YACZ,MAAMmE,EAAMzG,EAAYiB,OAClByF,EAAID,EAAIhF,OACRkF,EAAIF,EAAI,GAAGhF,OACXmF,EAAU,IAAIrC,MAAMmC,GAAGlC,OAAOC,IAAKjB,GAAM,IAAIe,MAAMoC,GAAGnC,MAAK,IAC3DqC,EAAUA,CAAClF,EAAGC,IAAMD,GAAK,GAAKA,EAAI+E,GAAK9E,GAAK,GAAKA,EAAI+E,EAC3DC,EAAQL,EAAI,IAAIA,EAAI,KAAM,EAC1B,MAAMO,EAAQ,CAAC,CAAEhE,SAAU,IAAIyD,GAAMQ,SAAU,EAAGC,KAAM,KAClDC,EAAU,CACd,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,EAAE,EAAG,IAGP,KAAOH,EAAMrF,OAAS,GAAG,CACvB,MAAMyF,EAAUJ,EAAMK,SAEhB,SAAErE,EAAQ,SAAEiE,EAAQ,KAAEC,GAASE,GAC9BE,EAAGC,GAAKvE,EAMf,GALAkE,EAAKM,KAAK,CAACF,EAAGC,UAERvB,EAAY,UAAWsB,EAAGC,GAChCT,EAAQQ,GAAGC,IAAK,EAEZD,IAAMZ,EAAI,IAAMa,IAAMb,EAAI,GAAI,CAChC,IAAK,IAAK7E,EAAGC,KAAMoF,QACXlB,EAAY,OAAQnE,EAAGC,GAE/B,MAEF,IAAK,IAAKD,EAAGC,KAAMqF,EAAS,CAC1B,IAAIM,EAAOH,EAAIzF,EACX6F,EAAOH,EAAIzF,EACXiF,EAAQU,EAAMC,KAEbZ,EAAQW,GAAMC,IACdxH,EAAYiC,OAAOsF,EAAMC,KAG1BZ,EAAQW,GAAMC,IAAQ,EACtBV,EAAMQ,KAAK,CACTxE,SAAU,CAACyE,EAAMC,GACjBT,SAAUA,EAAW,EACrBC,KAAM,IAAIA,EAAM,CAACO,EAAMC,WAQnC7B,IAAK3E,UACH,MAAMuF,EAAMvG,EAAYW,OAClB6F,EAAMxG,EAAYY,YAExBZ,EAAYsC,kBACNwD,EAAY,YAAaS,EAAI,GAAIA,EAAI,UACrCT,EAAY,YAAaS,EAAI,GAAIA,EAAI,IAC3C,MAAMK,EAAU,IAAIa,IACpB,IAAIC,EAAY,SAChB1G,eAAe2G,EAAOT,EAASF,GAC7B,MAAOI,EAAGC,GAAKH,EACf,GAAIlH,EAAYiC,OAAOmF,EAAGC,IAAMT,EAAQgB,IAAIR,EAAI,IAAMC,GAAI,OAAO,EAKjE,GAJAL,EAAKM,KAAK,CAACF,EAAGC,UACRvB,EAAY,UAAWsB,EAAGC,GAChCT,EAAQiB,IAAIT,EAAI,IAAMC,GAElBD,IAAMZ,EAAI,IAAMa,IAAMb,EAAI,GAE5B,OADAkB,EAAYV,GACL,EAET,MAAMC,EAAU,CACd,EAAE,EAAG,GACL,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,GAAI,IAEDP,EAAI1G,EAAYiB,OAAOQ,OACvBkF,EAAI3G,EAAYiB,OAAO,GAAGQ,OAC1BoF,EAAUA,CAAClF,EAAGC,IAAMD,GAAK,GAAKA,EAAI+E,GAAK9E,GAAK,GAAKA,EAAI+E,EAC3D,IAAK,IAAKhF,EAAGC,KAAMqF,EAAS,CAC1B,IAAIM,EAAOH,EAAIzF,EACX6F,EAAOH,EAAIzF,EACf,GAAIiF,EAAQU,EAAMC,GAAO,CAEvB,SADkBG,EAAO,CAACJ,EAAMC,GAAO,IAAIR,IAEzC,OAAO,GAIb,OAAO,EAGHW,CAAOpB,EAAK,IAClB,IAAK,IAAK5E,EAAGC,KAAM8F,QACX5B,EAAY,OAAQnE,EAAGC,IAGjCgE,SAAU5E,UACR,MAAMuF,EAAMvG,EAAYW,OAClB6F,EAAMxG,EAAYY,YACxBZ,EAAYsC,YACZ,MAAMrB,EAASjB,EAAYiB,OACrByF,EAAIzF,EAAOQ,OACXkF,EAAI1F,EAAO,GAAGQ,OACdqG,EAAY,IAAIL,IAChBM,EAAO,IAAIxD,MAAMmC,GACjBsB,EAAY,IAAIzD,MAAMmC,GAE5B,IAAK,IAAI/E,EAAI,EAAGA,EAAI+E,IAAK/E,EAAG,CAC1BoG,EAAKpG,GAAK,IAAI4C,MAAMoC,GAAGnC,KAAK,MAC5BwD,EAAUrG,GAAK,IAAI4C,MAAMoC,GAAGnC,KAAKyD,KACjC,IAAK,IAAIrG,EAAI,EAAGA,EAAI+E,IAAK/E,EACvBkG,EAAUD,IAAIlG,EAAI,IAAMC,GAI5B,MAAMsG,EAAYA,CAACvG,EAAGC,IAAMD,EAAI,IAAMC,EAChCuG,EAAYC,GAAYA,EAASA,EAAOC,MAAM,KAAK5D,IAAK6D,GAAQC,OAAOD,IAAQ,EAAE,GAAI,GAErFE,EAAaA,KAEjB,IAAIC,EAAcR,IACdS,EAAoB,KACxB,MAAMC,EAAYb,EAAUc,OAC5B,IAAK,IAAIC,KAAKF,EAAW,CACvB,MAAOhH,EAAGC,GAAKuG,EAASU,GACpBb,EAAUrG,GAAGC,GAAK6G,IACpBA,EAAcT,EAAUrG,GAAGC,GAC3B8G,EAAoBG,GAQxB,OALKH,IACHA,EAAoBC,EAAU,IAGhCb,EAAUgB,OAAOJ,GACVP,EAASO,IAEZK,EAAgBF,IACpB,MAAMG,EAAY,GAClB,IAAK5B,EAAGC,GAAKwB,EAEb,MAAM5B,EAAU,CACd,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,EAAE,EAAG,IAGP,IAAK,IAAKtF,EAAGC,KAAMqF,EAAS,CAC1B,IAAIM,EAAOH,EAAIzF,EACX6F,EAAOH,EAAIzF,EACX2F,GAAQ,GAAKA,EAAOb,GAAKc,GAAQ,GAAKA,EAAOb,IAAM3G,EAAYiC,OAAOsF,EAAMC,IAC9EwB,EAAU1B,KAAK,CAACC,EAAMC,IAI1B,OAAOwB,GAKT,IAFAhB,EAAUzB,EAAI,IAAIA,EAAI,IAAM,EAErBuB,EAAUmB,KAAO,GAAG,CACzB,MAAO7B,EAAGC,GAAKmB,IACf,IAAW,IAAPpB,IAAmB,IAAPC,EAEd,MAGF,SADMvB,EAAY,UAAWsB,EAAGC,GAC5BD,IAAMZ,EAAI,IAAMa,IAAMb,EAAI,GAE5B,MAEF,MAAMwC,EAAYD,EAAa,CAAC3B,EAAGC,IAEnC,IAAK,IAAI6B,KAAYF,EAAW,CAC9B,IAAKrH,EAAGC,GAAKsH,EAETL,EAAIX,EAAUvG,EAAGC,GACrB,GAAIkG,EAAUF,IAAIiB,GAAI,CACpB,MAAMM,EAAMnB,EAAUZ,GAAGC,IAAMpG,EAAOU,GAAGC,GAAGO,SAAW,EAAI,GAEvDgH,EAAMnB,EAAUrG,GAAGC,KACrBoG,EAAUrG,GAAGC,GAAKuH,EAClBpB,EAAKpG,GAAGC,GAAK,CAACwF,EAAGC,MAMzB,IAAI+B,EAAe,GACnB,GAAIrB,EAAKvB,EAAI,IAAIA,EAAI,IAAK,CACxB,IAAIU,EAAUV,EACd,KAAOU,GACLkC,EAAa9B,KAAKJ,GAClBA,EAAUa,EAAKb,EAAQ,IAAIA,EAAQ,IAIvCkC,EAAaC,UACb,IAAK,IAAK1H,EAAGC,KAAMwH,QACXtD,EAAY,OAAQnE,EAAGC,IAIjCiE,MAAO7E,UACL,MAAMuF,EAAMvG,EAAYW,OAClB6F,EAAMxG,EAAYY,YACxBZ,EAAYC,yBACZD,EAAYsC,YACZ,MAAMrB,EAASjB,EAAYiB,OACrByF,EAAIzF,EAAOQ,OACXkF,EAAI1F,EAAO,GAAGQ,OAEd6H,EAAU,IAAI7B,IACdM,EAAO,IAAIxD,MAAMmC,GACjB6C,EAAS,IAAIhF,MAAMmC,GACnB8C,EAAS,IAAIjF,MAAMmC,GAEnB+C,EAAeA,CAAC9H,EAAGC,IAChB8H,KAAKC,IAAIhI,EAAI6E,EAAI,IAAMkD,KAAKC,IAAI/H,EAAI4E,EAAI,IAGjD,IAAK,IAAI7E,EAAI,EAAGA,EAAI+E,IAAK/E,EAAG,CAC1B4H,EAAO5H,GAAK,IAAI4C,MAAMoC,GAAGnC,KAAKyD,KAC9BuB,EAAO7H,GAAK,IAAI4C,MAAMoC,GAAGnC,KAAKyD,KAC9BF,EAAKpG,GAAK,IAAI4C,MAAMoC,GACpB,IAAK,IAAI/E,EAAI,EAAGA,EAAI+E,IAAK/E,EACvBmG,EAAKpG,GAAGC,GAAK,KAIjB4H,EAAOjD,EAAI,IAAIA,EAAI,IAAMkD,EAAalD,EAAI,GAAIA,EAAI,IAClD+C,EAAQzB,IAAItB,EAAI,GAAK,IAAMA,EAAI,IAC/BgD,EAAOhD,EAAI,IAAIA,EAAI,IAAM,EAEzB,MAAM2B,EAAYA,CAACvG,EAAGC,IAAMD,EAAI,IAAMC,EAChCuG,EAAYC,GAAWA,EAAOC,MAAM,KAAK5D,IAAK6D,GAAQC,OAAOD,IAE7DE,EAAaA,KAEjB,IAAIoB,EAAY3B,IACZ4B,EAAkB,KACtB,MAAMlB,EAAYW,EAAQV,OAG1B,IAAK,IAAIC,KAAKF,EAAW,CACvB,MAAOhH,EAAGC,GAAKuG,EAASU,GAExB,GAAIW,EAAO7H,GAAGC,GAAKgI,EACjBA,EAAYJ,EAAO7H,GAAGC,GACtBiI,EAAkBhB,OACb,GAAIW,EAAO7H,GAAGC,KAAOgI,EAAW,CAErC,IAAKxC,EAAGC,GAAKc,EAAS0B,GAClBJ,EAAa9H,EAAGC,GAAK6H,EAAarC,EAAGC,KACvCuC,EAAYJ,EAAO7H,GAAGC,GACtBiI,EAAkBhB,IAMxB,OADAS,EAAQR,OAAOe,GACR1B,EAAS0B,IAGZd,EAAgBF,IACpB,MAAMG,EAAY,GAClB,IAAK5B,EAAGC,GAAKwB,EAGb,MAAM5B,EAAU,CACd,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,EAAE,EAAG,IAEP,IAAK,IAAKtF,EAAGC,KAAMqF,EAAS,CAC1B,IAAIM,EAAOH,EAAIzF,EACX6F,EAAOH,EAAIzF,EAGX2F,GAAQ,GAAKA,EAAOb,GAAKc,GAAQ,GAAKA,EAAOb,GAAkC,SAA7B1F,EAAOsG,GAAMC,GAAMxF,OACvEgH,EAAU1B,KAAK,CAACC,EAAMC,IAG1B,OAAOwB,GAGT,KAAOM,EAAQL,KAAO,GAAG,CACvB,MAAO7B,EAAGC,GAAKmB,IAIf,SAFM1C,EAAY,UAAWsB,EAAGC,GAE5BD,IAAMZ,EAAI,IAAMa,IAAMb,EAAI,GAE5B,MAEF,MAAMwC,EAAYD,EAAa,CAAC3B,EAAGC,IAEnC,IAAK,IAAI6B,KAAYF,EAAW,CAC9B,IAAKrH,EAAGC,GAAKsH,EACb,MAAMY,EAAmBP,EAAOnC,GAAGC,IAAMpG,EAAOU,GAAGC,GAAGO,SAAW,EAAI,GAGjE2H,EAAmBP,EAAO5H,GAAGC,KAC/B2H,EAAO5H,GAAGC,GAAKkI,EACf/B,EAAKpG,GAAGC,GAAK,CAACwF,EAAGC,GACjBmC,EAAO7H,GAAGC,GAAKkI,EAAmBL,EAAa9H,EAAGC,GAClD0H,EAAQzB,IAAIK,EAAUvG,EAAGC,MAI/B,MAAMwH,EAAe,GAErB,GAAIrB,EAAKvB,EAAI,IAAIA,EAAI,IAAK,CAExB,IAAIuD,EAAcvD,EAClB,KAAOuD,GACLX,EAAa9B,KAAKyC,GAClBA,EAAchC,EAAKgC,EAAY,IAAIA,EAAY,IAInDX,EAAaC,UAEb,IAAK,IAAK1H,EAAGC,KAAMwH,QACXtD,EAAY,OAAQnE,EAAGC,GAE/B5B,EAAYO,0BCnXDyJ,MAPkBnH,IAAwB,IAAvB,cAAEoH,GAAepH,EAIjD,OAAOO,IAAAC,cAAA,UAAQ6G,QAHKlJ,gBDFfA,eAA4BmJ,GACjC,KAAMA,KAAQ7D,GACZ,MAAM,IAAI8D,eAAe,wBAADjH,OAAyBgH,EAAI,qBAEvDnK,EAAYe,wBAA0BuF,EAAoB6D,GAC1DnK,EAAYC,yBACZD,EAAYQ,mBAAoB,QAC1B8F,EAAoB6D,KAC1BnK,EAAYQ,mBAAoB,EAChCR,EAAYO,wBCNJ8J,CAAaJ,KAEiBxE,EAA6BwE,KCLrE,MAAMnE,EAAc,SAACC,EAAOpE,EAAGC,GAAiC,IAA9BoE,EAAIC,UAAAxE,OAAA,QAAAyE,IAAAD,UAAA,GAAAA,UAAA,GAAGjG,EAAYkB,MACnD,OAAO,IAAIiF,QAASC,IACJ,SAAVL,IAAqB/F,EAAY0B,SAASC,EAAGC,IAAM5B,EAAY6B,cAAcF,EAAGC,IAClFwE,IAEAC,WAAW,KACTrG,EAAYiB,OAAOU,GAAGC,GAAGa,OAAO,CAC9Bf,SAAU1B,EAAY0B,SAASC,EAAGC,GAClCC,cAAe7B,EAAY6B,cAAcF,EAAGC,GAC5CI,MAAO+D,EACP5D,SAAUnC,EAAYkC,WAAWP,EAAGC,KAEtCwE,KACCJ,MAiBF,MAAMsE,EAA0B,CACrCC,kBAAmB,qBACnBC,cAAe,iBACfC,WAAY,cACZC,gBAAiB,oBACjBC,mBAAoB,wBAGhBC,EAAiB,CACrBL,kBAAmBvJ,UACjB,MAAM6J,EAAUA,CAACC,EAAKC,IACbrB,KAAKsB,MAAMtB,KAAKuB,UAAYF,EAAMD,EAAM,GAAKA,GAchDI,EAAgBA,CAACC,EAAMC,KAC3B,IAAIC,GAAa,EACjB,MAAMC,EAAW,GACjB,IAAK,IAAIhD,EAAM6C,EAAM7C,GAAO8C,IAAM9C,EAC5BA,EAAM,IAAM,GAAGgD,EAAShE,KAAKgB,GAEnC,GAAIgD,EAAS7J,OAAS,EAAG,CAEvB4J,EAAYC,EADIT,EAAQ,EAAGS,EAAS7J,OAAS,IAK/C,OAAO4J,GAGHE,EAAgBA,CAACJ,EAAMC,KAC3B,IAAII,GAAa,EAEjB,MAAMF,EAAW,GAEjB,IAAK,IAAIG,EAAMN,EAAMM,GAAOL,IAAMK,EAC5BA,EAAM,IAAM,GAAGH,EAAShE,KAAKmE,GAEnC,GAAIH,EAAS7J,OAAS,EAAG,CAEvB+J,EAAYF,EADIT,EAAQ,EAAGS,EAAS7J,OAAS,IAK/C,OAAO+J,GAGHE,EAAS1K,MAAOW,EAAGgK,EAAQ/J,EAAGgK,KAClC,GAAIA,GAAS,GAAKD,GAAU,EAC1B,OAGF,MAAME,EAhDkBC,EAACH,EAAQC,KACjC,IAAIC,EAAc,GAQlB,OANEA,EADEF,EAASC,EACG,aACLD,EAASC,EACJ,WAEAlC,KAAKuB,UAAY,GAAM,aAAe,WAE/CY,GAuCaC,CAAkBH,EAAQC,GAE9C,GAAoB,eAAhBC,EAA8B,CAChC,MAAMR,EAAYH,EAAcvJ,EAAI,EAAGA,EAAIgK,EAAS,GACpD,IAAmB,IAAfN,EAAkB,OAEtB,MAAMG,EAAYD,EAAc3J,EAAGA,EAAIgK,EAAQ,GAC/C,IAAmB,IAAfJ,EAAkB,OAEtB,IAAK,IAAIC,EAAM7J,EAAG6J,EAAM7J,EAAIgK,IAASH,EAC/BA,IAAQD,SACJ1F,EAAY,OAAQuF,EAAWI,SAInCC,EAAO/J,EAAG0J,EAAY1J,EAAGC,EAAGgK,SAC5BF,EAAOL,EAAY,EAAG1J,EAAIgK,EAASN,EAAY,EAAGzJ,EAAGgK,QACtD,GAAoB,aAAhBC,EAA4B,CACrC,IAAIR,EAAYH,EAActJ,EAAI,EAAGA,EAAIgK,EAAQ,GACjD,IAAmB,IAAfP,EAAkB,OAEtB,MAAMG,EAAYD,EAAc5J,EAAGA,EAAIgK,EAAS,GAChD,IAAmB,IAAfH,EAAkB,OACtB,IAAK,IAAIjJ,EAAMZ,EAAGY,EAAMZ,EAAIgK,IAAUpJ,EAChCA,IAAQiJ,SACJ1F,EAAY,OAAQvD,EAAK8I,SAG7BK,EAAO/J,EAAGgK,EAAQ/J,EAAGyJ,EAAYzJ,SACjC8J,EAAO/J,EAAGgK,EAAQN,EAAY,EAAGzJ,EAAIgK,EAAQP,EAAY,MAG5D3E,EAAGC,GAAK3G,EAAYuB,gBACrBmK,EAAO,EAAGhF,EAAG,EAAGC,GAKtB,MAAMJ,EAAMvG,EAAYW,OAClBoL,EAAkB,CACtB,CAACxF,EAAI,GAAK,EAAGA,EAAI,IACjB,CAACA,EAAI,GAAK,EAAGA,EAAI,IACjB,CAACA,EAAI,GAAIA,EAAI,GAAK,GAClB,CAACA,EAAI,GAAIA,EAAI,GAAK,IAClByF,OAAOnJ,IAAA,IAAElB,EAAGC,GAAEiB,EAAA,OAAKlB,GAAK,GAAKC,GAAK,GAAKD,EAAI+E,GAAK9E,EAAI+E,IAEtD,GAAIoF,EAAgBE,MAAMC,IAAA,IAAEvK,EAAGC,GAAEsK,EAAA,OAAKlM,EAAYiC,OAAON,EAAGC,KAAK,CAC/D,MAAMuK,EAAYtB,EAAQ,EAAGkB,EAAgBtK,OAAS,SAChDqE,EAAY,eAAgBiG,EAAgBI,IAGpD,MAAM3F,EAAMxG,EAAYY,YAClBwL,EAAuB,CAC3B,CAAC5F,EAAI,GAAK,EAAGA,EAAI,IACjB,CAACA,EAAI,GAAK,EAAGA,EAAI,IACjB,CAACA,EAAI,GAAIA,EAAI,GAAK,GAClB,CAACA,EAAI,GAAIA,EAAI,GAAK,IAClBwF,OAAOK,IAAA,IAAE1K,EAAGC,GAAEyK,EAAA,OAAK1K,GAAK,GAAKC,GAAK,GAAKD,EAAI+E,GAAK9E,EAAI+E,IAEtD,GAAIyF,EAAqBH,MAAMK,IAAA,IAAE3K,EAAGC,GAAE0K,EAAA,OAAKtM,EAAYiC,OAAON,EAAGC,KAAK,CACpE,MAAMuK,EAAYtB,EAAQ,EAAGuB,EAAqB3K,OAAS,SACrDqE,EAAY,eAAgBsG,EAAqBD,MAG3D3B,cAAexJ,UACb,MAAO0F,EAAGC,GAAK3G,EAAYuB,UAC3B,IAAIqF,EAAU,IAAIa,IAElB,MAAMS,EAAYqE,IAAA,IAAEnF,EAAGC,GAAEkF,EAAA,OAAKnF,EAAI,IAAMC,GAGlCjF,EAAYoK,IAAa,IAAXpF,EAAGC,GAAEmF,EACvB,OAAO5F,EAAQgB,IAAIR,EAAI,IAAMC,IAGzBoF,EAA0BA,CAACrF,EAAGC,EAAGN,KACrC,MAAMiC,EAAY,GAClB,IAAI/B,EAAU,CACZ,CAAC,EAAGF,GACJ,CAACA,EAAU,GACX,CAAC,GAAIA,GACL,EAAEA,EAAU,IAGd,IAAK,IAAKpF,EAAGC,KAAMqF,EAAS,CAC1B,IAAIM,EAAOH,EAAIzF,EACX6F,EAAOH,EAAIzF,EACX2F,GAAQ,GAAKA,EAAOb,GAAKc,GAAQ,GAAKA,EAAOb,GAC/CqC,EAAU1B,KAAK,CAACC,EAAMC,IAI1B,MAAMkF,EAAW,GACjB,KAAO1D,EAAUvH,OAAS,GAAG,CAC3B,MAAMkL,EAAI3D,EAAUvH,OAAS,EAC7B,IAAI0K,GA1BSrB,EA0BW,EA1BNC,EA0BS4B,EA1BDjD,KAAKsB,MAAMtB,KAAKuB,UAAYF,EAAMD,EAAM,IAAMA,GA2BxE4B,EAASpF,KAAK0B,EAAUmD,IAExB,MAAMS,EAAO5D,EAAUmD,GACvBnD,EAAUmD,GAAanD,EAAU2D,GACjC3D,EAAU2D,GAAKC,EAEf5D,EAAU6D,MAjCEhC,IAACC,EAAKC,EAoCpB,OAAO2B,GAOHI,EAAmBA,CAAC1F,EAAGC,IACpBoF,EAAwBrF,EAAGC,EAAG,GAGjC1B,EAAM3E,UACV,MAAOW,EAAGC,GAAKwG,EACf,GAAIhG,EAAUgG,GAAS,OAEvBxB,EAAQiB,IAAIK,EAAUE,IAEtB,MAAMY,EAbCyD,EAauB9K,EAAGC,EAbI,GAcrC,IAAK,IAAIsH,KAAYF,EACnB,IAAK5G,EAAU8G,GAAW,CACxB,MAAM6D,GAASpL,EAAIuH,EAAS,IAAM,EAC5B8D,GAASpL,EAAIsH,EAAS,IAAM,EAC7BlJ,EAAYiC,OAAO8K,EAAOC,UAAclH,EAAY,OAAQiH,EAAOC,GACpErL,IAAMoL,GACRA,EAAQ,GAAK,IAAM/M,EAAYiC,OAAO8K,EAAQ,EAAGC,UAAiBlH,EAAY,OAAQiH,EAAQ,EAAGC,GACjGD,EAAQ,EAAIrG,IAAM1G,EAAYiC,OAAO8K,EAAQ,EAAGC,UAAiBlH,EAAY,OAAQiH,EAAQ,EAAGC,IACvFpL,IAAMoL,IACfA,EAAQ,GAAK,IAAMhN,EAAYiC,OAAO8K,EAAOC,EAAQ,UAAalH,EAAY,OAAQiH,EAAOC,EAAQ,GACrGA,EAAQ,EAAIrG,IAAM3G,EAAYiC,OAAO8K,EAAOC,EAAQ,UAAalH,EAAY,OAAQiH,EAAOC,EAAQ,IAI1G,IAAK,IAAI9D,KAAYF,EACnB,IAAK5G,EAAU8G,GAAW,CACxB,MAAM+D,GAAStL,EAAIuH,EAAS,IAAM,EAC5BgE,GAAStL,EAAIsH,EAAS,IAAM,EAE5BiE,EAAgBL,EAAiBG,EAAOC,GAC9C,IAAK,IAAIE,KAAgBD,EAEpBnN,EAAYiC,OAAOmL,EAAa,GAAIA,EAAa,KACjDhL,EAAUgL,IACVlE,EAAS,KAAOkE,EAAa,IAAMlE,EAAS,KAAOkE,EAAa,UAE3DtH,EAAY,OAAQsH,EAAa,GAAIA,EAAa,UAGtDtH,EAAY,YAAamH,EAAOC,EAAO,GAC7CtG,EAAQiB,IAAIK,EAAU,CAAC+E,EAAOC,WACxBvH,EAAIuD,WAKVvD,EAAI,CAAC,EAAG,KAiBhB8E,WAAYzJ,UACV,MAAO0F,EAAGC,GAAK3G,EAAYuB,UAC3B,IAAK,IAAII,EAAI,EAAGA,EAAI+E,EAAG/E,GAAK,EAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAI+E,EAAG/E,GAAK,EAG1B,SAFMkE,EAAY,YAAanE,EAAGC,GAE9B8H,KAAKuB,UAAY,GAAK,CACxB,MAAMoC,EAAW1L,EAAI,EACf2L,EAAW1L,EACbyL,EAAW3G,GAAK4G,EAAW3G,UACvBb,EAAY,OAAQnE,EAAG2L,EAAW,SAClCxH,EAAY,OAAQuH,EAAUC,EAAW,QAE5C,CACL,MAAMD,EAAW1L,EACX2L,EAAW1L,EAAI,EACjByL,GAAY,GAAKA,EAAW3G,GAAK4G,GAAY,GAAKA,EAAW3G,UACzDb,EAAY,OAAQuH,EAAW,EAAGzL,SAClCkE,EAAY,OAAQuH,EAAW,EAAGC,MAMlD5C,gBAAiB1J,UACf,MAAO0F,EAAGC,GAAK3G,EAAYuB,UACrBqF,EAAU,IAAIa,IACdK,EAAY,IAAIL,IAChB8F,EAAY7D,KAAKsB,MAAMtE,EAAI,GAAMgD,KAAKsB,MAAMtE,EAAI,GAAK,EACrD8G,EAAY9D,KAAKsB,MAAMrE,EAAI,GAAM+C,KAAKsB,MAAMrE,EAAI,GAAK,EAC3DmB,EAAUD,IAAI,GAAD1E,OAAIoK,EAAS,KAAApK,OAAIqK,IAE9B,MAAM3C,EAAUA,CAACC,EAAKC,IACbrB,KAAKsB,MAAMtB,KAAKuB,UAAYF,EAAMD,EAAM,GAAKA,GAGhD1I,EAAYA,CAACT,EAAGC,IAAMgF,EAAQgB,IAAIjG,EAAI,IAAMC,GAE5C6L,EAAsCA,KAC1C,MAAMtB,EAAYtB,EAAQ,EAAG/C,EAAUmB,KAAO,GACxCyE,EAAanJ,MAAM4G,KAAKrD,EAAUc,QAAQuD,GAEhD,OADArE,EAAUgB,OAAO4E,GACVA,GAWHC,EAAmBA,CAAChM,EAAGC,IACT,CAChB,CAACD,EAAGC,EAAI,GACR,CAACD,EAAI,EAAGC,GACR,CAACD,EAAGC,EAAI,GACR,CAACD,EAAI,EAAGC,GACR,CAACD,EAAI,EAAGC,EAAI,GACZ,CAACD,EAAI,EAAGC,EAAI,GACZ,CAACD,EAAI,EAAGC,EAAI,GACZ,CAACD,EAAI,EAAGC,EAAI,IAEGoK,OAAO4B,IAAA,IAAEC,EAAGC,GAAEF,EAAA,OAAKC,GAAK,GAAKC,GAAK,GAAKD,EAAInH,GAAKoH,EAAInH,IAAMvE,EAAUyL,EAAGC,KAGpFC,EAAuBA,CAACpM,EAAGC,IACb,CAChB,CAACD,EAAGC,EAAI,GACR,CAACD,EAAI,EAAGC,GACR,CAACD,EAAGC,EAAI,GACR,CAACD,EAAI,EAAGC,IAEOoK,OAAOgC,IAAA,IAAEH,EAAGC,GAAEE,EAAA,OAAKH,GAAK,GAAKC,GAAK,GAAKD,EAAInH,GAAKoH,EAAInH,IAAMvE,EAAUyL,EAAGC,KAE1F,KAAOhG,EAAUmB,KAAO,GAAG,CACzB,MAAMb,EAASqF,KACRQ,EAAIC,GAAM9F,EAAOC,MAAM,KAAK5D,IAAKjB,GAAM+E,OAAO/E,UAC/CsC,EAAY,YAAamI,EAAIC,EAAI,GACvC,IAAK,IAAKvM,EAAGC,KAAM+L,EAAiBM,EAAIC,GACjClO,EAAYiC,OAAON,EAAGC,UAAUkE,EAAY,OAAQnE,EAAGC,GAE9DgF,EAAQiB,IAAIO,GACZ,MAAM+F,EAvCY,CAChB,CAFwBxM,EAwCiBsM,GAxCdrM,EAwCkBsM,GAtCrC,GACR,CAACvM,EAAI,EAAGC,GACR,CAACD,EAAGC,EAAI,GACR,CAACD,EAAI,EAAGC,IAEOoK,OAAOoC,IAAA,IAAEP,EAAGC,GAAEM,EAAA,OAAKP,GAAK,GAAKC,GAAK,GAAKD,EAAInH,GAAKoH,EAAInH,GAAKvE,EAAUyL,EAAGC,KAkCvF,GAAIK,EAAgB1M,OAAS,EAAG,CAC9B,MACMiM,EAAaS,EADDtD,EAAQ,EAAGsD,EAAgB1M,OAAS,UAEhD0E,QAAQkI,IAAI,CAChBvI,EAAY,YAAa4H,EAAW,GAAIA,EAAW,GAAI,GACvD5H,EAAY,aAAc4H,EAAW,GAAKO,GAAM,GAAIP,EAAW,GAAKQ,GAAM,EAAG,KAIvDH,EAAqBE,EAAIC,GACjC9N,QAAQkO,IAAa,IAAX3M,EAAGC,GAAE0M,EAC/BxG,EAAUD,IAAIlG,EAAI,IAAMC,KApDD2M,IAAC5M,EAAGC,GAwDjC+I,mBAAoB3J,UAClB,MAAO0F,EAAGC,GAAK3G,EAAYuB,UAErBiN,EAAgBA,CAAC7M,EAAGC,IAAMD,GAAK,GAAKA,EAAI+E,GAAK9E,GAAK,GAAKA,EAAI+E,EAE3D8H,EAA0BA,CAAC9M,EAAGC,IAChB,CAChB,CAACD,EAAGC,EAAI,GACR,CAACD,EAAI,EAAGC,GACR,CAACD,EAAGC,EAAI,GACR,CAACD,EAAI,EAAGC,IAEOoK,OAAO0C,IAAA,IAAEtH,EAAGC,GAAEqH,EAAA,OAAKF,EAAcpH,EAAGC,KAEjDsH,EAAkB,IAAIlH,IACtBmH,EAAiB,IAAInH,IAC3B,IAAK,IAAI9F,EAAI,EAAGA,EAAI+E,EAAG/E,GAAK,EAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAI+E,EAAG/E,GAAK,EAAG,CAC7B,MAAMiN,EAAmBJ,EAAwB9M,EAAGC,GACpD,IAAK,IAAKwF,EAAGC,KAAMwH,EAAkB,CACnC,MAAMC,EAAI,GAAA3L,OAAMuG,KAAKoB,IAAInJ,EAAGyF,GAAE,KAAAjE,OAAIuG,KAAKoB,IAAIlJ,EAAGyF,GAAE,KAAAlE,OAAIuG,KAAKqB,IAAIpJ,EAAGyF,GAAE,KAAAjE,OAAIuG,KAAKqB,IAAInJ,EAAGyF,IAClFuH,EAAe/G,IAAIiH,IAIzB,MAIMC,EAAyCA,KAC7C,MAAM5C,GALSrB,EAKW,EALNC,EAKS6D,EAAe3F,KAAO,EAJ5CS,KAAKsB,MAAMtB,KAAKuB,UAAYF,EAAMD,EAAM,GAAKA,IADtCD,IAACC,EAAKC,EAMpB,MAAM2C,EAAanJ,MAAM4G,KAAKyD,EAAehG,QAAQuD,GAErD,OADAyC,EAAe9F,OAAO4E,GACfA,GAGHsB,EAA4BhO,UAChC,MAAOiO,EAAIC,GAAMJ,EAAKzG,MAAM,MACrB8G,EAAIC,GAAMH,EAAG5G,MAAM,KAAK5D,IAAKjB,GAAM+E,OAAO/E,KAC1C6L,EAAIC,GAAMJ,EAAG7G,MAAM,KAAK5D,IAAKjB,GAAM+E,OAAO/E,IAE3C+L,EAAE,GAAApM,QAAOgM,EAAKE,GAAM,EAAC,KAAAlM,QAAKiM,EAAKE,GAAM,GAE3C,IAAK,IAAI3N,EAAIwN,EAAK,EAAGxN,GAAK0N,EAAK,EAAG1N,IAChC,IAAK,IAAIC,EAAIwN,EAAK,EAAGxN,GAAK0N,EAAK,EAAG1N,IAAK,CACrC,MAAM4N,EAAI,GAAArM,OAAMxB,EAAC,KAAAwB,OAAIvB,IAEnB4M,EAAc7M,EAAGC,IAChB,CAACqN,EAAIC,EAAIK,GAAIxN,SAASyN,IACtBb,EAAgB/G,IAAI4H,IACpBxP,EAAYiC,OAAON,EAAGC,UAEjBkE,EAAY,OAAQnE,EAAGC,KAM/B6N,EAAM,GAENC,EAAeA,CAACT,EAAIC,KACxB,IAAIS,EAAO,KACPC,EAAQ,CAACX,GACb,MAAMrI,EAAU,IAAIa,IACpB,KAAOmI,EAAMnO,QAAQ,CAGnB,GAFAkO,EAAOC,EAAM/C,MACbjG,EAAQiB,IAAI8H,GACRA,IAAST,EAAI,OAAO,EACxB,IAAK,IAAIhG,KAAYuG,EAAIE,IAAS,GAC3B/I,EAAQgB,IAAIsB,IACf0G,EAAMtI,KAAK4B,KAMnB,KAAO0F,EAAe3F,KAAO,GAAG,CAC9B,MAAM6F,EAAOC,UAEPC,EAA0BF,GAEhC,MAAOG,EAAIC,GAAMJ,EAAKzG,MAAM,MACrB8G,EAAIC,GAAMH,EAAG5G,MAAM,KAAK5D,IAAKjB,GAAM+E,OAAO/E,KAC1C6L,EAAIC,GAAMJ,EAAG7G,MAAM,KAAK5D,IAAKjB,GAAM+E,OAAO/E,IAE3C+L,EAAE,GAAApM,QAAOgM,EAAKE,GAAM,EAAC,KAAAlM,QAAKiM,EAAKE,GAAM,IACpCO,EAAIC,GAAMP,EAAGlH,MAAM,KAAK5D,IAAKjB,GAAM+E,OAAO/E,IAC5CkM,EAAaT,EAAIC,WACd/I,QAAQkI,IAAI,CAChBvI,EAAY,YAAaqJ,EAAIC,EAAI,GACjCtJ,EAAY,YAAauJ,EAAIC,EAAI,GACjCxJ,EAAY,YAAa+J,EAAIC,EAAI,KAEnCnB,EAAgB9G,IAAIoH,GACpBN,EAAgB9G,IAAIqH,GACpBP,EAAgB9G,IAAI0H,GACfE,EAAIR,KAAKQ,EAAIR,GAAM,IACnBQ,EAAIP,KAAKO,EAAIP,GAAM,IACxBO,EAAIR,GAAI3H,KAAK4H,GACbO,EAAIP,GAAI5H,KAAK2H,OC3cNc,MAPalN,IAAwB,IAAvB,cAAEoH,GAAepH,EAI5C,OAAOO,IAAAC,cAAA,UAAQ6G,QAHKlJ,gBDgBfA,eAAgCmJ,GACrC,KAAMA,KAAQS,GACZ,MAAM,IAAIR,eAAe,wBAADjH,OAAyBgH,EAAI,qBAEvDnK,EAAY2C,aACZ3C,EAAYC,yBACZD,EAAYQ,mBAAoB,QAC1BoK,EAAeT,KACrBnK,EAAYQ,mBAAoB,EAChCR,EAAYO,wBCxBJyP,CAAiB/F,KAEaK,EAAwBL,K,uHCmIjDgG,MA3HMA,KACnB,MAAMC,EAAaC,iBAAO,MACpBC,EAAqBD,iBAAO,MAC5BE,EAAiBF,iBAAO,MAyB9B,OAxBAG,oBAAU,KACRJ,EAAWhJ,QAAQqJ,MAAQ,IAC3BH,EAAmBlJ,QAAQsJ,SAAU,EACrCH,EAAenJ,QAAQsJ,SAAU,EACjCxQ,EAAYkB,MAAQ,EAEpB,MAAMuP,EAAejN,IACL,MAAVA,EAAEmB,MACJ3E,EAAYoB,UAAW,IAGrBsP,EAAalN,IACH,MAAVA,EAAEmB,MACJ3E,EAAYoB,UAAW,IAM3B,OAHAuP,OAAOC,iBAAiB,UAAWH,GACnCE,OAAOC,iBAAiB,QAASF,GAE1B,WACLC,OAAOE,oBAAoBJ,GAC3BE,OAAOE,oBAAoBH,KAE5B,IAEDtN,IAAAC,cAAA,OAAKK,UAAU,gBACbN,IAAAC,cAAA,OAAKK,UAAU,SACbN,IAAAC,cAAA,SAAOK,UAAU,eAAc,wBAC/BN,IAAAC,cAAC2G,EAAwB,CAACC,cAAe,QACzC7G,IAAAC,cAAC2G,EAAwB,CAACC,cAAe,QACzC7G,IAAAC,cAAC2G,EAAwB,CAACC,cAAe,aACzC7G,IAAAC,cAAC2G,EAAwB,CAACC,cAAe,WAE3C7G,IAAAC,cAAA,OAAKK,UAAU,SACbN,IAAAC,cAAA,SAAOK,UAAU,eAAc,mBAC/BN,IAAAC,cAAC0M,EAAmB,CAAC9F,cAAe,sBACpC7G,IAAAC,cAAC0M,EAAmB,CAAC9F,cAAe,kBACpC7G,IAAAC,cAAC0M,EAAmB,CAAC9F,cAAe,eACpC7G,IAAAC,cAAC0M,EAAmB,CAAC9F,cAAe,oBACpC7G,IAAAC,cAAC0M,EAAmB,CAAC9F,cAAe,wBAEtC7G,IAAAC,cAAA,OAAKK,UAAU,SACbN,IAAAC,cAAA,SAAOK,UAAU,eAAc,gBAC/BN,IAAAC,cAAA,UACE6G,QAASlJ,UACPhB,EAAY2C,eAEf,eAGDS,IAAAC,cAAA,UACE6G,QAASlJ,UACPhB,EAAYsC,cAEf,cAGDc,IAAAC,cAAA,OAAKK,UAAU,aACbN,IAAAC,cAAA,SAAOyN,QAAQ,cAAa,UAC5B1N,IAAAC,cAAA,SACE0N,IAAKb,EACLc,KAAK,QACLlG,IAAI,IACJC,IAAI,MACJkG,SAAWzN,IACTxD,EAAYkB,MAAQ,IAAMqH,OAAO/E,EAAE0N,OAAOX,WAIhDnN,IAAAC,cAAA,OAAKK,UAAU,aACbN,IAAAC,cAAA,SAAOyN,QAAQ,sBAAqB,cACpC1N,IAAAC,cAAA,SACE4N,SAAUA,KACRjR,EAAYU,YAAcV,EAAYU,YAExCqQ,IAAKX,EACLY,KAAK,cAGT5N,IAAAC,cAAA,OAAKK,UAAU,aACbN,IAAAC,cAAA,SAAOyN,QAAQ,kBAAiB,uBAChC1N,IAAAC,cAAA,SACE4N,SAAUA,KACRjR,EAAYS,iBAAmBT,EAAYS,iBAE7CsQ,IAAKV,EACLW,KAAK,eAIX5N,IAAAC,cAAA,OAAKK,UAAU,SACbN,IAAAC,cAAA,SAAOK,UAAU,eAAc,SAC/BN,IAAAC,cAAA,OAAKK,UAAU,gBACbN,IAAAC,cAAA,OAAKkD,IAAK4K,IAAYhI,IAAI,oBAC1B/F,IAAAC,cAAA,aAAO,eACPD,IAAAC,cAAA,OAAKkD,IAAK6K,IAAiBjI,IAAI,eAC/B/F,IAAAC,cAAA,aAAO,qBAETD,IAAAC,cAAA,OAAKK,UAAU,gBACbN,IAAAC,cAAA,OAAKkD,IAAK8K,IAAUlI,IAAI,aACxB/F,IAAAC,cAAA,aAAO,aACPD,IAAAC,cAAA,OAAKkD,IAAK+K,IAAYnI,IAAI,eAC1B/F,IAAAC,cAAA,aAAO,kBAETD,IAAAC,cAAA,OAAKK,UAAU,gBACbN,IAAAC,cAAA,OAAKkD,IAAKgL,IAAepI,IAAI,kBAC7B/F,IAAAC,cAAA,aAAO,kBACPD,IAAAC,cAAA,OAAKkD,IAAKiL,IAAarI,IAAI,gBAC3B/F,IAAAC,cAAA,aAAO,iBAETD,IAAAC,cAAA,OAAKK,UAAU,gBACbN,IAAAC,cAAA,OAAKkD,IAAKkL,IAAUtI,IAAI,aACxB/F,IAAAC,cAAA,aAAO,iB,MClHFqO,MAZHA,KACVpB,oBAAU,KACRpQ,SAASyR,MAAQ,4CAChB,IAEDvO,IAAAC,cAAA,OAAKK,UAAU,YACbN,IAAAC,cAAC4M,EAAY,MACb7M,IAAAC,cAACuB,EAAI,CAACC,SAAU,GAAIR,YAAa,GAAIS,kBAAmB,CAAC,GAAI,IAAKC,gBAAiB,CAAC,GAAI,QCP9F6M,IAASC,OAAOzO,IAAAC,cAACqO,EAAG,MAAKxR,SAAS4R,eAAe,W","file":"static/js/main.ae3637b7.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAeNQTFRFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////RtSC+QAAAJ90Uk5TAAY/lMvuyZE9ATaj5tGYbmrSojIFZ+TDWRUXW+J+6oEUBAOFeXAQVZOvrlNpPOO7vZvpOYIIEki6CeBDE76p51AezqwYGYwRe9wqK3WGiAq/jZbAG91oHd5kZmsiSh9YTthvdtVxB7OmAqiqVOhST6RjLaDbSZrhXRrTf4+QJtAPi0HUOryxDrZEhDi5iYo3XmLflcTFMKerLJJG71992ml4TwAAAAFiS0dEoF7TvqAAAAAJcEhZcwAAD20AAA9tAXNIKB4AAAIQSURBVDjLfZP7XxJBFMUPqLQUCRagS8smhqRYgJEVKJoPRCuzzNWlZBMiknJ7WGZaaZlFpb3fZvqvNrAsywp6f5jPPXu+M7Nz7wxQCI22orJqa6tKt4fSoDT0e/cZ9lcbTSZjdY3hwMES32yx1tbR+hxqO1TLWMxqX2NnD9dnE0dDdqw/wjrVhIltdACuo03N7qYWF+Ea2WPF/nGPncykvKyvtdV3wusnxEmPX/Hb3L5TwGnPGSoABChvsB3oCHW2FQBt11mgu6e3T5Lh5spuoKVLWwD6dRFgYPCcrM8PXgAiuiFZB0IXgeFLl5U9R64MAxWhQF6OcmPAOB9VgKv8OHCNG83LCS4GCPx1BajjBSDGTcgAPwnY4gkFuBG3AZO8DNDJm0BDpzsl+6lbU6QsziSd1+nbd0gZp8W7MjAt3iOlct9Pyx8eMDPkLA8fzUrNinGPSY1m5p4UtpxfeJo9TK/4jBIE6rk4FSZyaGFe+amB+CIZXYklkWHEnsQLIhbjzqJmCcmXudXpZYtluSO3T/8robidRuuK+oJQVlW7EXn9JlOsM2+9EfWMdwZjsUwY2tU+0u+ZVUWtzNn12wDQvjVayb00SsIf/OCQMsfH4CeUiTH2s5R8YaPlfKRGvq5KS31LlQUQ9n0nd1H4sdaHHeJn8lcm87vmD3aMWc/6OvMXu0R0Y+Pfbj7Mm5vbXu1/oU5fEc5PvloAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTktMDUtMTNUMTk6MjA6NDMrMDE6MDALHs5ZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE5LTA1LTEzVDE5OjIwOjQzKzAxOjAwekN25QAAAEZ0RVh0c29mdHdhcmUASW1hZ2VNYWdpY2sgNi43LjgtOSAyMDE5LTAyLTAxIFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZ0F74sgAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADUxMsDQUFEAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgANTEyHHwD3AAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNTU3NzcxNjQzWLQQjQAAABF0RVh0VGh1bWI6OlNpemUAMTdLQkJGvmi8AAAAQ3RFWHRUaHVtYjo6VVJJAGZpbGU6Ly8uL3VwbG9hZHMvNTYvZFJudFUzei8xOTM2L3BsYWNlaG9sZGVyMV8xMjIzNzgucG5n8qgBDAAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAA5QAAAOUBj+WbPAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAErSURBVFiF7ZZBSgNBFERfqWQXoqDiMngKl55AdOtCFDyAJ/AcgoLiRSQ7zyAoCAoRJERECKL8LJKRyZ8/o0KcuOiCv6kpeh7dNc1gZmQDLAHPgAFb+Wd/NQtMqgV8AGfAgaR1pquemV3mDQ+Q6RPYHk9eN8CV81aBHee9A+fBunuSOmZ2/+W4I2gDXeCE0TH4ufBbCGwEuX603eO123lvrmQHalMCKCshwC3w4LxHSZvOWwY6zhsEOYBGwako4VFQon2KhbsOcotBLptUwv8FUFXCpqQ15wl4cl4vyDWDHMBKwUk3YQKYNUDVVxBpV5L/R5gPci1J/ZL3vf0U4Bg4/R3ftxqY2QRYFcCrmXWnDFDQzDuQABJAAkgAZQDR/V4LwAuj6/kQuKsDYAjlHSrEjxxhcgAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG0AAABuCAYAAAAtbJ34AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAEYSURBVHhe7dHBCcAwAAMxp/vv3ObRJQQnMB7gzrb3LpDn/0CKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigooGKBioaqGigonG2D4DMAdvmC+R4AAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAB4CAYAAAAnrQZhAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIVSURBVHhe7dGhcUMBFMTAdJ/u0ohJYNg31xwwjN4IbAX79f3zenJPsUcVe1SxRxV7VLFHFXtUsUcVe1SxR30U+/v35B9ZR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI6oWKF1RMUKrSMqVmgdUbFC64iKFVpHVKzQOqJihdYRFSu0jqhYoXVExQqtIypWaB1RsULriIoVWkdUrNA6omKF1hEVK7SOqFihdUTFCq0jKlZoHVGxQuuIihVaR1Ss0DqiYoXWERUrtI7oo9j4FHtUsUcVe1SxRxV7VLFHFXtUsUcVe9LreQNncxQk3K89qQAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIsSURBVHhe7dgxUQMAFAVB3KMhpjCSGSwEAWyRDt6fK1bBdffx+fV85a4CH1fg4wp8XIGPK/BxBT6uwMcV+Li3Az8e3/lH1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqNpMCj1EgKPEqN5O3A2VTg4wp8XIGPK/BxBT6uwMcV+LgCH1fg494OrF2Wv6NGvz1fP6xss6BalwdDAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAABtCAYAAABAz1RVAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAEUSURBVHhe7dExDQAwDMCwbvw5d89IRLKfAMjZnR1y7i8xxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2VclHFRxkUZF2Vc0swD6O0D1yemuPIAAAAASUVORK5CYII=\"","const gridOptions = {\r\n  disableUserInteraction: function () {\r\n    document.querySelectorAll(\"#controlPanel button\").forEach((elem) => (elem.disabled = true));\r\n  },\r\n  enableUserInteraction: function () {\r\n    document.querySelectorAll(\"#controlPanel button\").forEach((elem) => (elem.disabled = false));\r\n  },\r\n  animationLaunched: false,\r\n  animationOnDrop: true,\r\n  isAnimated: true,\r\n  source: [],\r\n  destination: [],\r\n  isSourceDragged: false,\r\n  isDestinationDragged: false,\r\n  chozenAlgorithmCallback: async () => {},\r\n  matrix: null,\r\n  delay: 0,\r\n  clicked: false,\r\n  wpressed: false,\r\n  sourceDragged: false,\r\n  destinationDragged: false,\r\n  getSize: function () {\r\n    return [this.matrix.length, this.matrix[0].length];\r\n  },\r\n  isSource: function (i, j) {\r\n    return this.matrix[i][j].isSource;\r\n  },\r\n  isDestination: function (i, j) {\r\n    return this.matrix[i][j].isDestination;\r\n  },\r\n  isUnvisited: function (i, j) {\r\n    return [\"unvisited\", \"unvisited-animated\"].includes(this.matrix[i][j].class);\r\n  },\r\n\r\n  isWall: function (i, j) {\r\n    return [\"wall\", \"wall-animated\"].includes(this.matrix[i][j].class);\r\n  },\r\n  isWeighted: function (i, j) {\r\n    return this.matrix[i][j].weighted;\r\n  },\r\n  isVisited: function (i, j) {\r\n    return [\"visited\", \"visited-animated\"].includes(this.matrix[i][j].class);\r\n  },\r\n  isPath: function (i, j) {\r\n    return [\"path\", \"path-animated\"].includes(this.matrix[i][j].class);\r\n  },\r\n  clearPath: function () {\r\n    for (let row of this.matrix) {\r\n      for (let cell of row) {\r\n        if ([\"path\", \"path-animated\", \"visited\", \"visited-animated\"].includes(cell.class)) {\r\n          cell.update({\r\n            ...cell,\r\n            class: \"unvisited\",\r\n          });\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  clearBoard: function () {\r\n    for (let row of this.matrix) {\r\n      for (let cell of row) {\r\n        cell.update({\r\n          ...cell,\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n        });\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default gridOptions;\r\n","import React, { useState } from \"react\";\r\nimport gridOptions from \"../gridOptions\";\r\nimport \"../Assets/Styles/cell.css\";\r\n\r\nconst Cell = ({ position: { i, j } }) => {\r\n  const [options, setOptions] = useState({\r\n    class: gridOptions.matrix[i][j].class,\r\n    weighted: gridOptions.matrix[i][j].weighted,\r\n    isSource: gridOptions.matrix[i][j].isSource,\r\n    isDestination: gridOptions.matrix[i][j].isDestination,\r\n  });\r\n  gridOptions.matrix[i][j].update = setOptions;\r\n  gridOptions.matrix[i][j].class = options.class;\r\n  gridOptions.matrix[i][j].weighted = options.weighted;\r\n  gridOptions.matrix[i][j].isSource = options.isSource;\r\n  gridOptions.matrix[i][j].isDestination = options.isDestination;\r\n\r\n  let classList = \"cell \" + (options.isSource ? \"source \" : \"\") + (options.isDestination ? \"destination \" : \"\");\r\n  if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged || !gridOptions.isAnimated) {\r\n    // if animation is turned off or source / destination are being dragged (and dropped), then set\r\n    // classes without \"-animated\" suffixes for rendering WITHOUT animation\r\n    classList += options.class + (options.weighted ? \" weight \" : \"\");\r\n  } else {\r\n    // else add \"-animated\" suffix to the end of the animated classes for rendering WITH animation\r\n    classList += `${options.class}-animated ` + (options.weighted ? \"weight-animated \" : \"\");\r\n  }\r\n\r\n  const handleMouseDown = (e) => {\r\n    if (e.button !== 0 || gridOptions.animationLaunched) return;\r\n\r\n    gridOptions.clicked = true;\r\n\r\n    if (gridOptions.matrix[i][j].isSource) {\r\n      gridOptions.isSourceDragged = true;\r\n    } else if (gridOptions.matrix[i][j].isDestination) {\r\n      gridOptions.isDestinationDragged = true;\r\n    } else {\r\n      if (!gridOptions.wpressed) {\r\n        setOptions({\r\n          ...options,\r\n          weighted: false,\r\n          class: options.class === \"wall\" ? \"unvisited\" : \"wall\",\r\n        });\r\n      } else if (gridOptions.wpressed) {\r\n        setOptions({\r\n          ...options,\r\n          class: \"unvisited\",\r\n          weighted: !options.weighted,\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleMouseOver = async () => {\r\n    if (!gridOptions.clicked || gridOptions.matrix[i][j].isSource || gridOptions.matrix[i][j].isDestination) return;\r\n\r\n    if (gridOptions.isSourceDragged) {\r\n      gridOptions.clearPath();\r\n      const [prevSource_i, prevSource_j] = gridOptions.source;\r\n      const prevSourceOptions = gridOptions.matrix[prevSource_i][prevSource_j];\r\n\r\n      gridOptions.matrix[prevSource_i][prevSource_j].update({\r\n        ...prevSourceOptions,\r\n        isSource: false,\r\n      });\r\n      gridOptions.source = [i, j];\r\n\r\n      gridOptions.matrix[i][j].update({\r\n        ...options,\r\n        isSource: true,\r\n      });\r\n    } else if (gridOptions.isDestinationDragged) {\r\n      gridOptions.clearPath();\r\n      const [prevDestination_i, prevDestination_j] = gridOptions.destination;\r\n      const prevDestinationOptions = gridOptions.matrix[prevDestination_i][prevDestination_j];\r\n      gridOptions.matrix[prevDestination_i][prevDestination_j].update({\r\n        ...prevDestinationOptions,\r\n        isDestination: false,\r\n      });\r\n      gridOptions.destination = [i, j];\r\n      gridOptions.matrix[i][j].update({\r\n        ...options,\r\n        isDestination: true,\r\n      });\r\n    } else if (gridOptions.wpressed) {\r\n      // drawing a weighted node\r\n      setOptions({\r\n        ...options,\r\n        class: \"unvisited\",\r\n        weighted: !options.weighted,\r\n      });\r\n    } else {\r\n      // drawing a wall\r\n      setOptions({\r\n        ...options,\r\n        weighted: false,\r\n        class: options.class === \"wall\" ? \"unvisited\" : \"wall\",\r\n      });\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div\r\n      id={i + \",\" + j}\r\n      onDragStart={(e) => {\r\n        e.preventDefault();\r\n      }}\r\n      className={classList}\r\n      onMouseDown={handleMouseDown}\r\n      onMouseOver={handleMouseOver}\r\n    />\r\n  );\r\n};\r\n\r\nexport default Cell;\r\n","import React from \"react\";\r\nimport Cell from \"./Cell\";\r\nimport \"../Assets/Styles/row.css\";\r\n\r\nconst Row = ({ i, columnCount }) => {\r\n  const cells = new Array(columnCount).fill().map((_, j) => {\r\n    return <Cell position={{ i, j }} key={i + \",\" + j} />;\r\n  });\r\n  return <div className=\"row\">{cells}</div>;\r\n};\r\n\r\nexport default Row;\r\n","import React from \"react\";\r\nimport Row from \"./Row\";\r\nimport gridOptions from \"../gridOptions\";\r\nimport \"../Assets/Styles/grid.css\";\r\n\r\nconst Grid = ({ rowCount, columnCount, startNodePosition, endNodePosition }) => {\r\n  const rows = new Array(rowCount).fill().map((_, i) => <Row key={i.toString()} i={i} columnCount={columnCount} />);\r\n  gridOptions.matrix = new Array(rowCount);\r\n  for (let i = 0; i < rowCount; ++i) {\r\n    gridOptions.matrix[i] = new Array(columnCount);\r\n    for (let j = 0; j < columnCount; ++j) {\r\n      gridOptions.matrix[i][j] = { class: \"unvisited\", weighted: false };\r\n    }\r\n  }\r\n  const [start_i, start_j] = startNodePosition;\r\n  const [end_i, end_j] = endNodePosition;\r\n  gridOptions.matrix[start_i][start_j].isSource = true;\r\n  gridOptions.matrix[end_i][end_j].isDestination = true;\r\n  gridOptions.source = [start_i, start_j];\r\n  gridOptions.destination = [end_i, end_j];\r\n\r\n  const handleMouseUp = async (e) => {\r\n    if (e.button !== 0) return;\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      gridOptions.clearPath();\r\n      if (gridOptions.isSourceDragged) {\r\n        const [i, j] = gridOptions.source;\r\n        gridOptions.matrix[i][j].update({\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n          isSource: true,\r\n          isDestination: false,\r\n        });\r\n      } else if (gridOptions.isDestinationDragged) {\r\n        const [i, j] = gridOptions.destination;\r\n        gridOptions.matrix[i][j].update({\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n          isSource: false,\r\n          isDestination: true,\r\n        });\r\n      }\r\n      if (gridOptions.animationOnDrop) {\r\n        await gridOptions.chozenAlgorithmCallback();\r\n      }\r\n    }\r\n    gridOptions.isSourceDragged = false;\r\n    gridOptions.isDestinationDragged = false;\r\n    gridOptions.clicked = false;\r\n    gridOptions.wpressed = false;\r\n  };\r\n\r\n  const handleMouseLeave = async () => {\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      gridOptions.clearPath();\r\n      if (gridOptions.isSourceDragged) {\r\n        const [i, j] = gridOptions.source;\r\n        gridOptions.matrix[i][j].update({\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n          isSource: true,\r\n          isDestination: false,\r\n        });\r\n      } else if (gridOptions.isDestinationDragged) {\r\n        const [i, j] = gridOptions.destination;\r\n        gridOptions.matrix[i][j].update({\r\n          class: \"unvisited\",\r\n          weighted: false,\r\n          isSource: false,\r\n          isDestination: true,\r\n        });\r\n      }\r\n      if (gridOptions.animationOnDrop) {\r\n        await gridOptions.chozenAlgorithmCallback();\r\n      }\r\n    }\r\n    gridOptions.clicked = false;\r\n    gridOptions.wpressed = false;\r\n    gridOptions.isSourceDragged = false;\r\n    gridOptions.isDestinationDragged = false;\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        onDragStart={(e) => {\r\n          e.preventDefault();\r\n        }}\r\n        className=\"grid\"\r\n        onMouseUp={handleMouseUp}\r\n        onMouseLeave={handleMouseLeave}\r\n      >\r\n        {rows}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","import gridOptions from \"../gridOptions\";\r\n\r\nexport async function runAlgorithm(name) {\r\n  if (!(name in searchingAlgorithms)) {\r\n    throw new ReferenceError(`Algorithm with name '${name}' is not defined`);\r\n  }\r\n  gridOptions.chozenAlgorithmCallback = searchingAlgorithms[name];\r\n  gridOptions.disableUserInteraction();\r\n  gridOptions.animationLaunched = true;\r\n  await searchingAlgorithms[name]();\r\n  gridOptions.animationLaunched = false;\r\n  gridOptions.enableUserInteraction();\r\n}\r\n\r\nexport const searchingAlgorithmsFullNames = {\r\n  bfs: \"Breadth First Search\",\r\n  dfs: \"Depth First Search\",\r\n  dijkstra: \"Dijkstra's Algorithm\",\r\n  astar: \"A* Algorithm\",\r\n};\r\n\r\nexport const animateCell = (state, i, j, time = gridOptions.delay) => {\r\n  return new Promise((resolve) => {\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      // when dragging either source or destination,update current cell immediately WITHOUT animation\r\n      gridOptions.matrix[i][j].update({\r\n        isSource: gridOptions.isSource(i, j),\r\n        isDestination: gridOptions.isDestination(i, j),\r\n        class: state,\r\n        weighted: gridOptions.isWeighted(i, j),\r\n      });\r\n      resolve();\r\n    } else {\r\n      setTimeout(() => {\r\n        gridOptions.matrix[i][j].update({\r\n          isSource: gridOptions.isSource(i, j),\r\n          isDestination: gridOptions.isDestination(i, j),\r\n          class: state,\r\n          weighted: gridOptions.isWeighted(i, j),\r\n        });\r\n        resolve();\r\n      }, time);\r\n    }\r\n  });\r\n};\r\n\r\nexport const searchingAlgorithms = {\r\n  bfs: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.clearPath();\r\n    const mat = gridOptions.matrix;\r\n    const n = mat.length;\r\n    const m = mat[0].length;\r\n    const visited = new Array(n).fill().map((e) => new Array(m).fill(false));\r\n    const isValid = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n    visited[src[0]][src[1]] = true;\r\n    const queue = [{ position: [...src], distance: 0, path: [] }];\r\n    const addends = [\r\n      [0, 1],\r\n      [1, 0],\r\n      [0, -1],\r\n      [-1, 0],\r\n    ];\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift();\r\n\r\n      const { position, distance, path } = current;\r\n      const [x, y] = position;\r\n      path.push([x, y]);\r\n\r\n      await animateCell(\"visited\", x, y);\r\n      visited[x][y] = true;\r\n\r\n      if (x === dst[0] && y === dst[1]) {\r\n        for (let [i, j] of path) {\r\n          await animateCell(\"path\", i, j);\r\n        }\r\n        break;\r\n      }\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (isValid(newX, newY)) {\r\n          if (\r\n            !visited[newX][newY] &&\r\n            !gridOptions.isWall(newX, newY)\r\n            // gridOptions.matrix[newX][newY].class !== 'wall'\r\n          ) {\r\n            visited[newX][newY] = true;\r\n            queue.push({\r\n              position: [newX, newY],\r\n              distance: distance + 1,\r\n              path: [...path, [newX, newY]],\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  dfs: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n\r\n    gridOptions.clearPath();\r\n    await animateCell(\"unvisited\", src[0], src[1]);\r\n    await animateCell(\"unvisited\", src[0], src[1]);\r\n    const visited = new Set();\r\n    let foundPath = [];\r\n    async function search(current, path) {\r\n      const [x, y] = current;\r\n      if (gridOptions.isWall(x, y) || visited.has(x + \",\" + y)) return false;\r\n      path.push([x, y]);\r\n      await animateCell(\"visited\", x, y);\r\n      visited.add(x + \",\" + y);\r\n      // if ()) return false;\r\n      if (x === dst[0] && y === dst[1]) {\r\n        foundPath = path;\r\n        return true;\r\n      }\r\n      const addends = [\r\n        [-1, 0],\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n      ];\r\n      const n = gridOptions.matrix.length;\r\n      const m = gridOptions.matrix[0].length;\r\n      const isValid = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (isValid(newX, newY)) {\r\n          let found = await search([newX, newY], [...path]);\r\n          if (found) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    await search(src, []);\r\n    for (let [i, j] of foundPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n  },\r\n  dijkstra: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.clearPath();\r\n    const matrix = gridOptions.matrix;\r\n    const n = matrix.length;\r\n    const m = matrix[0].length;\r\n    const unvisited = new Set();\r\n    const prev = new Array(n);\r\n    const distances = new Array(n);\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n      prev[i] = new Array(m).fill(null);\r\n      distances[i] = new Array(m).fill(Infinity);\r\n      for (let j = 0; j < m; ++j) {\r\n        unvisited.add(i + \",\" + j);\r\n      }\r\n    }\r\n\r\n    const stringify = (i, j) => i + \",\" + j;\r\n    const indexify = (vertex) => (vertex ? vertex.split(\",\").map((idx) => Number(idx)) : [-1, -1]);\r\n\r\n    const extractMin = () => {\r\n      // finds the vertex with minimum distance, removes it from the \"unvisited\" set and returns it\r\n      let minDistance = Infinity;\r\n      let minDistanceVertex = null;\r\n      const verticies = unvisited.keys();\r\n      for (let v of verticies) {\r\n        const [i, j] = indexify(v);\r\n        if (distances[i][j] < minDistance) {\r\n          minDistance = distances[i][j];\r\n          minDistanceVertex = v;\r\n        }\r\n      }\r\n      if (!minDistanceVertex) {\r\n        minDistanceVertex = verticies[0];\r\n      }\r\n\r\n      unvisited.delete(minDistanceVertex);\r\n      return indexify(minDistanceVertex);\r\n    };\r\n    const getNeighbors = (v) => {\r\n      const neighbors = [];\r\n      let [x, y] = v;\r\n\r\n      const addends = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n        [-1, 0],\r\n      ];\r\n\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && !gridOptions.isWall(newX, newY)) {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n\r\n      return neighbors;\r\n    };\r\n\r\n    distances[src[0]][src[1]] = 0;\r\n\r\n    while (unvisited.size > 0) {\r\n      const [x, y] = extractMin();\r\n      if (x === -1 || y === -1) {\r\n        // there is no path\r\n        break;\r\n      }\r\n      await animateCell(\"visited\", x, y);\r\n      if (x === dst[0] && y === dst[1]) {\r\n        // found the shortest path\r\n        break;\r\n      }\r\n      const neighbors = getNeighbors([x, y]);\r\n\r\n      for (let neighbor of neighbors) {\r\n        let [i, j] = neighbor;\r\n\r\n        let v = stringify(i, j);\r\n        if (unvisited.has(v)) {\r\n          const alt = distances[x][y] + (matrix[i][j].weighted ? 5 : 1);\r\n\r\n          if (alt < distances[i][j]) {\r\n            distances[i][j] = alt;\r\n            prev[i][j] = [x, y];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let shortestPath = [];\r\n    if (prev[dst[0]][dst[1]]) {\r\n      let current = dst;\r\n      while (current) {\r\n        shortestPath.push(current);\r\n        current = prev[current[0]][current[1]];\r\n      }\r\n    }\r\n\r\n    shortestPath.reverse();\r\n    for (let [i, j] of shortestPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n  },\r\n\r\n  astar: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.disableUserInteraction();\r\n    gridOptions.clearPath();\r\n    const matrix = gridOptions.matrix;\r\n    const n = matrix.length;\r\n    const m = matrix[0].length;\r\n\r\n    const openSet = new Set();\r\n    const prev = new Array(n);\r\n    const gScore = new Array(n);\r\n    const fScore = new Array(n);\r\n\r\n    const getHeruistic = (i, j) => {\r\n      return Math.abs(i - dst[0]) + Math.abs(j - dst[1]);\r\n    };\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n      gScore[i] = new Array(m).fill(Infinity);\r\n      fScore[i] = new Array(m).fill(Infinity);\r\n      prev[i] = new Array(m);\r\n      for (let j = 0; j < m; ++j) {\r\n        prev[i][j] = null;\r\n      }\r\n    }\r\n\r\n    fScore[src[0]][src[1]] = getHeruistic(src[0], src[1]);\r\n    openSet.add(src[0] + \",\" + src[1]);\r\n    gScore[src[0]][src[1]] = 0;\r\n\r\n    const stringify = (i, j) => i + \",\" + j; // returns hash value for two indicies of the vertex\r\n    const indexify = (vertex) => vertex.split(\",\").map((idx) => Number(idx)); // returns two indicies from hash value of the vertex\r\n\r\n    const extractMin = () => {\r\n      // finds the vertex with minimum distance, removes it from the \"openSet\" and returns it\r\n      let minFScore = Infinity;\r\n      let minFScoreVertex = null;\r\n      const verticies = openSet.keys();\r\n\r\n      // find the vertex in openSet with minimum fScore\r\n      for (let v of verticies) {\r\n        const [i, j] = indexify(v);\r\n\r\n        if (fScore[i][j] < minFScore) {\r\n          minFScore = fScore[i][j];\r\n          minFScoreVertex = v;\r\n        } else if (fScore[i][j] === minFScore) {\r\n          // if fscores are equal, choose a vertex with lower herustic score\r\n          let [x, y] = indexify(minFScoreVertex);\r\n          if (getHeruistic(i, j) < getHeruistic(x, y)) {\r\n            minFScore = fScore[i][j];\r\n            minFScoreVertex = v;\r\n          }\r\n        }\r\n      }\r\n\r\n      openSet.delete(minFScoreVertex);\r\n      return indexify(minFScoreVertex);\r\n    };\r\n\r\n    const getNeighbors = (v) => {\r\n      const neighbors = [];\r\n      let [x, y] = v;\r\n\r\n      // addendsd for possible directions we can move from v\r\n      const addends = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n        [-1, 0],\r\n      ];\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n\r\n        // validating possible neighbor coordinates\r\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && matrix[newX][newY].class !== \"wall\") {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n      return neighbors;\r\n    };\r\n\r\n    while (openSet.size > 0) {\r\n      const [x, y] = extractMin(); // extract the node with minimal fScore in openSet and remove it from the set\r\n\r\n      await animateCell(\"visited\", x, y);\r\n\r\n      if (x === dst[0] && y === dst[1]) {\r\n        // prev[x][y].push([x, y]);\r\n        break;\r\n      }\r\n      const neighbors = getNeighbors([x, y]);\r\n\r\n      for (let neighbor of neighbors) {\r\n        let [i, j] = neighbor;\r\n        const tentative_gScore = gScore[x][y] + (matrix[i][j].weighted ? 5 : 1);\r\n\r\n        // await sleepPromise('visited', i, j);\r\n        if (tentative_gScore < gScore[i][j]) {\r\n          gScore[i][j] = tentative_gScore;\r\n          prev[i][j] = [x, y];\r\n          fScore[i][j] = tentative_gScore + getHeruistic(i, j);\r\n          openSet.add(stringify(i, j));\r\n        }\r\n      }\r\n    }\r\n    const shortestPath = [];\r\n\r\n    if (prev[dst[0]][dst[1]]) {\r\n      // if the path found, than construct the shortestPath via backtracking from the destination node\r\n      let currentNode = dst;\r\n      while (currentNode) {\r\n        shortestPath.push(currentNode);\r\n        currentNode = prev[currentNode[0]][currentNode[1]];\r\n      }\r\n    }\r\n\r\n    shortestPath.reverse(); // reversing the path to get it in right order (from source to destination)\r\n\r\n    for (let [i, j] of shortestPath) {\r\n      await animateCell(\"path\", i, j);\r\n    }\r\n    gridOptions.enableUserInteraction();\r\n  },\r\n};\r\n","import React from \"react\";\nimport { runAlgorithm, searchingAlgorithmsFullNames } from \"../Algorithms/searchingAlgorithms\";\n\nconst SearchingAlgorithmButton = ({ algorithmName }) => {\n  const handleClick = async () => {\n    await runAlgorithm(algorithmName);\n  };\n  return <button onClick={handleClick}>{searchingAlgorithmsFullNames[algorithmName]}</button>;\n};\n\nexport default SearchingAlgorithmButton;\n","import gridOptions from \"../gridOptions\";\n\nconst animateCell = (state, i, j, time = gridOptions.delay) => {\n  return new Promise((resolve) => {\n    if (state === \"wall\" && (gridOptions.isSource(i, j) || gridOptions.isDestination(i, j))) {\n      resolve();\n    } else {\n      setTimeout(() => {\n        gridOptions.matrix[i][j].update({\n          isSource: gridOptions.isSource(i, j),\n          isDestination: gridOptions.isDestination(i, j),\n          class: state,\n          weighted: gridOptions.isWeighted(i, j),\n        });\n        resolve();\n      }, time);\n    }\n  });\n};\n\nexport async function runMazeAlgorithm(name) {\n  if (!(name in mazeAlgorithms)) {\n    throw new ReferenceError(`Algorithm with name '${name}' is not defined`);\n  }\n  gridOptions.clearBoard();\n  gridOptions.disableUserInteraction();\n  gridOptions.animationLaunched = true;\n  await mazeAlgorithms[name]();\n  gridOptions.animationLaunched = false;\n  gridOptions.enableUserInteraction();\n}\n\nexport const mazeAlgorithmsFullNames = {\n  recursiveDivision: \"Recursive Division\",\n  randomizedDFS: \"Randomized DFS\",\n  binaryTree: \"Binary Tree\",\n  primsRandomized: \"Prim's randomized\",\n  kruskalsRandomized: \"Kruskal's randomized\",\n};\n\nconst mazeAlgorithms = {\n  recursiveDivision: async () => {\n    const randInt = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    const chooseOrientation = (height, width) => {\n      let orientation = \"\";\n      if (height > width) {\n        orientation = \"Horizontal\";\n      } else if (height < width) {\n        orientation = \"Vertical\";\n      } else {\n        orientation = Math.random() <= 0.5 ? \"Horizontal\" : \"Vertical\";\n      }\n      return orientation;\n    };\n    const randWallIndex = (from, to) => {\n      let wallIndex = -1;\n      const indicies = [];\n      for (let idx = from; idx <= to; ++idx) {\n        if (idx % 2 !== 0) indicies.push(idx);\n      }\n      if (indicies.length > 0) {\n        let randIndex = randInt(0, indicies.length - 1);\n        wallIndex = indicies[randIndex];\n        // wallIndex = indicies[Math.floor(indicies.length / 2)];\n      }\n\n      return wallIndex;\n    };\n\n    const randHoleIndex = (from, to) => {\n      let holeIndex = -1;\n\n      const indicies = [];\n\n      for (let col = from; col <= to; ++col) {\n        if (col % 2 === 0) indicies.push(col);\n      }\n      if (indicies.length > 0) {\n        let randIndex = randInt(0, indicies.length - 1);\n        holeIndex = indicies[randIndex];\n        // holeIndex = indicies[Math.floor(indicies.length / 2)];\n      }\n\n      return holeIndex;\n    };\n\n    const divide = async (i, height, j, width) => {\n      if (width <= 2 || height <= 2) {\n        return;\n      }\n\n      const orientation = chooseOrientation(height, width);\n\n      if (orientation === \"Horizontal\") {\n        const wallIndex = randWallIndex(i + 1, i + height - 2);\n        if (wallIndex === -1) return;\n\n        const holeIndex = randHoleIndex(j, j + width - 1);\n        if (holeIndex === -1) return;\n\n        for (let col = j; col < j + width; ++col) {\n          if (col !== holeIndex) {\n            await animateCell(\"wall\", wallIndex, col);\n          }\n        }\n\n        await divide(i, wallIndex - i, j, width);\n        await divide(wallIndex + 1, i + height - wallIndex - 1, j, width);\n      } else if (orientation === \"Vertical\") {\n        let wallIndex = randWallIndex(j + 1, j + width - 2);\n        if (wallIndex === -1) return;\n\n        const holeIndex = randHoleIndex(i, i + height - 1);\n        if (holeIndex === -1) return;\n        for (let row = i; row < i + height; ++row) {\n          if (row !== holeIndex) {\n            await animateCell(\"wall\", row, wallIndex);\n          }\n        }\n        await divide(i, height, j, wallIndex - j);\n        await divide(i, height, wallIndex + 1, j + width - wallIndex - 1);\n      }\n    };\n    const [n, m] = gridOptions.getSize();\n    await divide(0, n, 0, m);\n\n    // check if source or destination are disconnected from the grid (are surrounded by walls),\n    //    if so, randomly remove one of the walls\n\n    const src = gridOptions.source;\n    const sourceNeighbors = [\n      [src[0] + 1, src[1]],\n      [src[0] - 1, src[1]],\n      [src[0], src[1] + 1],\n      [src[0], src[1] - 1],\n    ].filter(([i, j]) => i >= 0 && j >= 0 && i < n && j < m);\n\n    if (sourceNeighbors.every(([i, j]) => gridOptions.isWall(i, j))) {\n      const randIndex = randInt(0, sourceNeighbors.length - 1);\n      await animateCell(\"unvisited\", ...sourceNeighbors[randIndex]);\n    }\n\n    const dst = gridOptions.destination;\n    const destinationNeighbors = [\n      [dst[0] + 1, dst[1]],\n      [dst[0] - 1, dst[1]],\n      [dst[0], dst[1] + 1],\n      [dst[0], dst[1] - 1],\n    ].filter(([i, j]) => i >= 0 && j >= 0 && i < n && j < m);\n\n    if (destinationNeighbors.every(([i, j]) => gridOptions.isWall(i, j))) {\n      const randIndex = randInt(0, destinationNeighbors.length - 1);\n      await animateCell(\"unvisited\", ...destinationNeighbors[randIndex]);\n    }\n  },\n  randomizedDFS: async () => {\n    const [n, m] = gridOptions.getSize();\n    let visited = new Set();\n\n    const stringify = ([x, y]) => x + \",\" + y;\n    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n    const isVisited = ([x, y]) => {\n      return visited.has(x + \",\" + y);\n    };\n\n    const getNeigborsWithDistance = (x, y, distance) => {\n      const neighbors = [];\n      let addends = [\n        [0, distance],\n        [distance, 0],\n        [0, -distance],\n        [-distance, 0],\n      ];\n\n      for (let [i, j] of addends) {\n        let newX = x + i;\n        let newY = y + j;\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m) {\n          neighbors.push([newX, newY]);\n        }\n      }\n      // randomly shuffle with Fisher–Yates algorithm\n      const shuffled = [];\n      while (neighbors.length > 0) {\n        const l = neighbors.length - 1;\n        let randIndex = randInt(0, l);\n        shuffled.push(neighbors[randIndex]);\n\n        const temp = neighbors[randIndex];\n        neighbors[randIndex] = neighbors[l];\n        neighbors[l] = temp;\n\n        neighbors.pop();\n      }\n\n      return shuffled;\n    };\n\n    const getNeigbors = (x, y) => {\n      return getNeigborsWithDistance(x, y, 2);\n    };\n\n    const getHoleNeighbors = (x, y) => {\n      return getNeigborsWithDistance(x, y, 1);\n    };\n\n    const dfs = async (vertex) => {\n      const [i, j] = vertex;\n      if (isVisited(vertex)) return;\n\n      visited.add(stringify(vertex));\n\n      const neighbors = getNeigbors(i, j);\n      for (let neighbor of neighbors) {\n        if (!isVisited(neighbor)) {\n          const wallI = (i + neighbor[0]) / 2;\n          const wallJ = (j + neighbor[1]) / 2;\n          if (!gridOptions.isWall(wallI, wallJ)) await animateCell(\"wall\", wallI, wallJ);\n          if (i === wallI) {\n            wallI - 1 >= 0 && !gridOptions.isWall(wallI - 1, wallJ) && (await animateCell(\"wall\", wallI - 1, wallJ));\n            wallI + 1 < n && !gridOptions.isWall(wallI + 1, wallJ) && (await animateCell(\"wall\", wallI + 1, wallJ));\n          } else if (j === wallJ) {\n            wallJ - 1 >= 0 && !gridOptions.isWall(wallI, wallJ - 1) && (await animateCell(\"wall\", wallI, wallJ - 1));\n            wallJ + 1 < m && !gridOptions.isWall(wallI, wallJ + 1) && (await animateCell(\"wall\", wallI, wallJ + 1));\n          }\n        }\n      }\n      for (let neighbor of neighbors) {\n        if (!isVisited(neighbor)) {\n          const holeI = (i + neighbor[0]) / 2;\n          const holeJ = (j + neighbor[1]) / 2;\n\n          const holeNeighbors = getHoleNeighbors(holeI, holeJ);\n          for (let holeNeighbor of holeNeighbors) {\n            if (\n              !gridOptions.isWall(holeNeighbor[0], holeNeighbor[1]) &&\n              !isVisited(holeNeighbor) &&\n              (neighbor[0] !== holeNeighbor[0] || neighbor[1] !== holeNeighbor[1])\n            ) {\n              await animateCell(\"wall\", holeNeighbor[0], holeNeighbor[1]);\n            }\n          }\n          await animateCell(\"unvisited\", holeI, holeJ, 0);\n          visited.add(stringify([holeI, holeJ]));\n          await dfs(neighbor);\n        }\n      }\n    };\n\n    await dfs([0, 0]);\n\n    // adding walls to unreachable cells (which are considered to be walls)\n    // for (let i = 1; i < n; i += 2) {\n    //   for (let j = 1; j < m; j += 2) {\n    //     if (\n    //       gridOptions.isUnvisited(i, j) &&\n    //       getHoleNeighbors(i, j).every(([row, col]) => {\n    //         return gridOptions.isWall(row, col);\n    //       })\n    //     ) {\n    //       await animateCell(\"wall\", i, j);\n    //     }\n    //   }\n    // }\n  },\n\n  binaryTree: async () => {\n    const [n, m] = gridOptions.getSize();\n    for (let i = 2; i < n; i += 2) {\n      for (let j = 2; j < m; j += 2) {\n        await animateCell(\"unvisited\", i, j);\n        // randomly chooze connection direciton either north or west\n        if (Math.random() <= 0.5) {\n          const passageI = i - 1;\n          const passageJ = j;\n          if (passageI < n && passageJ < m) {\n            await animateCell(\"wall\", i, passageJ - 1);\n            await animateCell(\"wall\", passageI, passageJ - 1);\n          }\n        } else {\n          const passageI = i;\n          const passageJ = j - 1;\n          if (passageI >= 1 && passageI < n && passageJ >= 0 && passageJ < m) {\n            await animateCell(\"wall\", passageI - 1, j);\n            await animateCell(\"wall\", passageI - 1, passageJ);\n          }\n        }\n      }\n    }\n  },\n  primsRandomized: async () => {\n    const [n, m] = gridOptions.getSize();\n    const visited = new Set();\n    const unvisited = new Set();\n    const middleRow = Math.floor(n / 2) - (Math.floor(n / 2) % 2);\n    const middleCol = Math.floor(m / 2) - (Math.floor(m / 2) % 2);\n    unvisited.add(`${middleRow},${middleCol}`);\n\n    const randInt = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    const isVisited = (i, j) => visited.has(i + \",\" + j);\n\n    const extractRandomVertexFromUnvisitedSet = () => {\n      const randIndex = randInt(0, unvisited.size - 1);\n      const randVertex = Array.from(unvisited.keys())[randIndex];\n      unvisited.delete(randVertex);\n      return randVertex;\n    };\n    const getVisitedNeigbors = (i, j) => {\n      const neighbors = [\n        [i, j + 2],\n        [i + 2, j],\n        [i, j - 2],\n        [i - 2, j],\n      ];\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && isVisited(r, c));\n    };\n    const getWallNeighbors = (i, j) => {\n      const neighbors = [\n        [i, j + 1],\n        [i + 1, j],\n        [i, j - 1],\n        [i - 1, j],\n        [i + 1, j + 1],\n        [i + 1, j - 1],\n        [i - 1, j - 1],\n        [i - 1, j + 1],\n      ];\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && !isVisited(r, c));\n    };\n\n    const getUnvisitedNeigbors = (i, j) => {\n      const neighbors = [\n        [i, j + 2],\n        [i + 2, j],\n        [i, j - 2],\n        [i - 2, j],\n      ];\n      return neighbors.filter(([r, c]) => r >= 0 && c >= 0 && r < n && c < m && !isVisited(r, c));\n    };\n    while (unvisited.size > 0) {\n      const vertex = extractRandomVertexFromUnvisitedSet();\n      const [vi, vj] = vertex.split(\",\").map((e) => Number(e));\n      await animateCell(\"unvisited\", vi, vj, 0);\n      for (let [i, j] of getWallNeighbors(vi, vj)) {\n        if (!gridOptions.isWall(i, j)) await animateCell(\"wall\", i, j);\n      }\n      visited.add(vertex);\n      const visitedNeigbors = getVisitedNeigbors(vi, vj);\n      if (visitedNeigbors.length > 0) {\n        const randIndex = randInt(0, visitedNeigbors.length - 1);\n        const randVertex = visitedNeigbors[randIndex];\n        await Promise.all([\n          animateCell(\"unvisited\", randVertex[0], randVertex[1], 0),\n          animateCell(\"unvisited\", (randVertex[0] + vi) / 2, (randVertex[1] + vj) / 2, 0),\n        ]);\n      }\n\n      const unvisitedNeigbors = getUnvisitedNeigbors(vi, vj);\n      unvisitedNeigbors.forEach(([i, j]) => {\n        unvisited.add(i + \",\" + j);\n      });\n    }\n  },\n  kruskalsRandomized: async () => {\n    const [n, m] = gridOptions.getSize();\n\n    const isValidVertex = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\n\n    const getAllPossibleNeighbors = (i, j) => {\n      const neighbors = [\n        [i, j + 2],\n        [i + 2, j],\n        [i, j - 2],\n        [i - 2, j],\n      ];\n      return neighbors.filter(([x, y]) => isValidVertex(x, y));\n    };\n    const visitedVertices = new Set();\n    const unvisitedEdges = new Set();\n    for (let i = 0; i < n; i += 2) {\n      for (let j = 0; j < m; j += 2) {\n        const possibleNeigbors = getAllPossibleNeighbors(i, j);\n        for (let [x, y] of possibleNeigbors) {\n          const edge = `${Math.min(i, x)},${Math.min(j, y)}-${Math.max(i, x)},${Math.max(j, y)}`; // sorted\n          unvisitedEdges.add(edge);\n        }\n      }\n    }\n    const randInt = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    const extractRandomEdgeFromUnvisitedEdgesSet = () => {\n      const randIndex = randInt(0, unvisitedEdges.size - 1);\n      const randVertex = Array.from(unvisitedEdges.keys())[randIndex];\n      unvisitedEdges.delete(randVertex);\n      return randVertex;\n    };\n\n    const addSurroundingWallsToEdge = async (edge) => {\n      const [v1, v2] = edge.split(\"-\");\n      const [i1, j1] = v1.split(\",\").map((e) => Number(e));\n      const [i2, j2] = v2.split(\",\").map((e) => Number(e));\n\n      const vm = `${(i1 + i2) / 2},${(j1 + j2) / 2}`; // the vertex between v1 and v2\n\n      for (let i = i1 - 1; i <= i2 + 1; i++) {\n        for (let j = j1 - 1; j <= j2 + 1; j++) {\n          const wall = `${i},${j}`;\n          if (\n            isValidVertex(i, j) &&\n            ![v1, v2, vm].includes(wall) &&\n            !visitedVertices.has(wall) &&\n            !gridOptions.isWall(i, j)\n          ) {\n            await animateCell(\"wall\", i, j);\n          }\n        }\n      }\n    };\n\n    const adj = {};\n\n    const areConnected = (v1, v2) => {\n      let curr = null;\n      let stack = [v1];\n      const visited = new Set();\n      while (stack.length) {\n        curr = stack.pop();\n        visited.add(curr);\n        if (curr === v2) return true;\n        for (let neighbor of adj[curr] || []) {\n          if (!visited.has(neighbor)) {\n            stack.push(neighbor);\n          }\n        }\n      }\n    };\n\n    while (unvisitedEdges.size > 0) {\n      const edge = extractRandomEdgeFromUnvisitedEdgesSet();\n\n      await addSurroundingWallsToEdge(edge);\n\n      const [v1, v2] = edge.split(\"-\");\n      const [i1, j1] = v1.split(\",\").map((e) => Number(e));\n      const [i2, j2] = v2.split(\",\").map((e) => Number(e));\n\n      const vm = `${(i1 + i2) / 2},${(j1 + j2) / 2}`; // the vertex between v1 and v2\n      const [im, jm] = vm.split(\",\").map((e) => Number(e));\n      if (!areConnected(v1, v2)) {\n        await Promise.all([\n          animateCell(\"unvisited\", i1, j1, 0),\n          animateCell(\"unvisited\", i2, j2, 0),\n          animateCell(\"unvisited\", im, jm, 0),\n        ]);\n        visitedVertices.add(v1);\n        visitedVertices.add(v2);\n        visitedVertices.add(vm);\n        if (!adj[v1]) adj[v1] = [];\n        if (!adj[v2]) adj[v2] = [];\n        adj[v1].push(v2);\n        adj[v2].push(v1);\n      }\n    }\n  },\n};\n","import React from \"react\";\nimport { runMazeAlgorithm, mazeAlgorithmsFullNames } from \"../Algorithms/mazeAlgorithms\";\n\nconst MazeAlgorithmButton = ({ algorithmName }) => {\n  const handleClick = async () => {\n    await runMazeAlgorithm(algorithmName);\n  };\n  return <button onClick={handleClick}>{mazeAlgorithmsFullNames[algorithmName]}</button>;\n};\n\nexport default MazeAlgorithmButton;\n","import React, { useEffect, useRef } from \"react\";\r\nimport SearchingAlgorithmButton from \"./SearchingAlgorithmButton\";\r\nimport MazeAlgorithmButton from \"./MazeAlgorithmButton\";\r\n\r\nimport gridOptions from \"../gridOptions\";\r\n\r\nimport sourceIcon from \"../Assets/Icons/source.png\";\r\nimport destinationIcon from \"../Assets/Icons/destination.png\";\r\nimport wallIcon from \"../Assets/Icons/wall.png\";\r\nimport weightIcon from \"../Assets/Icons/weight.png\";\r\nimport unvisitedIcon from \"../Assets/Icons/unvisited.png\";\r\nimport visitedIcon from \"../Assets/Icons/visited.png\";\r\nimport pathIcon from \"../Assets/Icons/path.png\";\r\nimport \"../Assets/Styles/controlPanel.css\";\r\n\r\nconst ControlPanel = () => {\r\n  const speedInput = useRef(null);\r\n  const isAnimatedCheckBox = useRef(null);\r\n  const anmationOnDrop = useRef(null);\r\n  useEffect(() => {\r\n    speedInput.current.value = 200;\r\n    isAnimatedCheckBox.current.checked = true;\r\n    anmationOnDrop.current.checked = true;\r\n    gridOptions.delay = 0;\r\n\r\n    const handleWDown = (e) => {\r\n      if (e.key === \"w\") {\r\n        gridOptions.wpressed = true;\r\n      }\r\n    };\r\n    const handleWUp = (e) => {\r\n      if (e.key === \"w\") {\r\n        gridOptions.wpressed = false;\r\n      }\r\n    };\r\n    window.addEventListener(\"keydown\", handleWDown);\r\n    window.addEventListener(\"keyup\", handleWUp);\r\n\r\n    return function cleanUp() {\r\n      window.removeEventListener(handleWDown);\r\n      window.removeEventListener(handleWUp);\r\n    };\r\n  }, []);\r\n  return (\r\n    <div className=\"controlPanel\">\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Searching Algorithms</label>\r\n        <SearchingAlgorithmButton algorithmName={\"bfs\"} />\r\n        <SearchingAlgorithmButton algorithmName={\"dfs\"} />\r\n        <SearchingAlgorithmButton algorithmName={\"dijkstra\"} />\r\n        <SearchingAlgorithmButton algorithmName={\"astar\"} />\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Maze Algorithms</label>\r\n        <MazeAlgorithmButton algorithmName={\"recursiveDivision\"} />\r\n        <MazeAlgorithmButton algorithmName={\"randomizedDFS\"} />\r\n        <MazeAlgorithmButton algorithmName={\"binaryTree\"} />\r\n        <MazeAlgorithmButton algorithmName={\"primsRandomized\"} />\r\n        <MazeAlgorithmButton algorithmName={\"kruskalsRandomized\"} />\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Grid options</label>\r\n        <button\r\n          onClick={async () => {\r\n            gridOptions.clearBoard();\r\n          }}\r\n        >\r\n          Clear Board\r\n        </button>\r\n        <button\r\n          onClick={async () => {\r\n            gridOptions.clearPath();\r\n          }}\r\n        >\r\n          Clear Path\r\n        </button>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"speedInput\">Speed:</label>\r\n          <input\r\n            ref={speedInput}\r\n            type=\"range\"\r\n            min=\"0\"\r\n            max=\"200\"\r\n            onChange={(e) => {\r\n              gridOptions.delay = 200 - Number(e.target.value);\r\n            }}\r\n          />\r\n        </div>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"isAnimatedCheckBox\">Animated: </label>\r\n          <input\r\n            onChange={() => {\r\n              gridOptions.isAnimated = !gridOptions.isAnimated;\r\n            }}\r\n            ref={isAnimatedCheckBox}\r\n            type=\"checkbox\"\r\n          />\r\n        </div>\r\n        <div className=\"input-box\">\r\n          <label htmlFor=\"anmationOnDrop\">Animation on drop: </label>\r\n          <input\r\n            onChange={() => {\r\n              gridOptions.animationOnDrop = !gridOptions.animationOnDrop;\r\n            }}\r\n            ref={anmationOnDrop}\r\n            type=\"checkbox\"\r\n          />\r\n        </div>\r\n      </div>\r\n      <div className=\"panel\">\r\n        <label className=\"panel-title\">Icons</label>\r\n        <div className=\"inline-block\">\r\n          <img src={sourceIcon} alt=\"destination.png\" />\r\n          <label>Source node</label>\r\n          <img src={destinationIcon} alt=\"source.png\" />\r\n          <label>Destination node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={wallIcon} alt=\"wall.png\" />\r\n          <label>Wall node</label>\r\n          <img src={weightIcon} alt=\"source.png\" />\r\n          <label>Weighted node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={unvisitedIcon} alt=\"unvisited.png\" />\r\n          <label>Unvisited node</label>\r\n          <img src={visitedIcon} alt=\"visited.png\" />\r\n          <label>Visited node</label>\r\n        </div>\r\n        <div className=\"inline-block\">\r\n          <img src={pathIcon} alt=\"path.png\" />\r\n          <label>Path node</label>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ControlPanel;\r\n","import React, { useEffect } from \"react\";\nimport Grid from \"./Grid\";\nimport ControlPanel from \"./ControlPanel\";\nimport \"../Assets/Styles/app.css\";\n\nconst App = () => {\n  useEffect(() => {\n    document.title = \"Pathfinding & Maze Generating visualizer\";\n  }, []);\n  return (\n    <div className=\"flex-box\">\n      <ControlPanel />\n      <Grid rowCount={25} columnCount={55} startNodePosition={[11, 10]} endNodePosition={[11, 40]} />\n    </div>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./Components/App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}
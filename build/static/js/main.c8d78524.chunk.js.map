{"version":3,"sources":["gridOptions.js","Cell.js","Row.js","Grid.js","algorithms.js","mazeAlgorithms.js","ControlPanel.js","App.js","index.js"],"names":["gridOptions","disableUserInteraction","document","querySelectorAll","forEach","elem","disabled","enableUserInteraction","animationLaunched","isAnimated","source","destination","isSourceDragged","isDestinationDragged","chozenAlgorithmCallback","a","matrix","delay","clicked","wpressed","sourceDragged","destinationDragged","getSize","this","length","isSource","i","j","isDestination","isUnvisited","includes","class","isWall","isWeighted","weighted","isVisited","isPath","clearPath","row","cell","update","clearBoard","Cell","position","useState","options","setOptions","classList","id","onDragStart","e","preventDefault","className","onMouseDown","button","onMouseOver","prevSource_i","prevSource_j","prevSourceOptions","prevDestination_i","prevDestination_j","prevDestinationOptions","Row","columnCount","Array","fill","map","_","key","Grid","rowCount","startNodePosition","endNodePosition","rows","toString","start_i","start_j","end_i","end_j","onMouseUp","onMouseLeave","runAlgorithm","name","searchingAlgorithms","ReferenceError","animateCell","state","time","Promise","resolve","setTimeout","bfs","src","dst","mat","n","m","visited","isValid","queue","distance","path","addends","current","shift","x","y","push","newX","newY","dfs","search","has","add","foundPath","Set","dijkstra","unvisited","prev","distances","Infinity","stringify","indexify","vertex","split","idx","Number","extractMin","minDistance","minDistanceVertex","verticies","keys","v","delete","getNeighbors","neighbors","size","neighbor","alt","shortestPath","reverse","astar","openSet","gScore","fScore","getHeruistic","Math","abs","minFScore","minFScoreVertex","tentative_gScore","currentNode","runMazeAlgorithm","mazeAlgorithms","recursiveDivision","randInt","min","max","floor","random","chooseOrientation","height","width","randWallIndex","from","to","wallIndex","indicies","randHoleIndex","holeIndex","col","divide","orientation","sourceNeighbors","filter","every","randIndex","destinationNeighbors","randomizedDFS","getNeigborsWithDistance","shuffled","l","temp","pop","getNeigbors","getHoleNeighbors","wallI","wallJ","holeI","holeJ","holeNeighbors","holeNeighbor","binaryTree","passageJ","passageI","primsRandomizedAlgorithm","extractRandomVertexFromUnvisitedSet","randVertex","getVisitedNeigbors","r","c","getWallNeighbors","getUnvisitedNeigbors","vi","vj","visitedNeigbors","ControlPanel","useEffect","getElementById","value","checked","body","addEventListener","wallToggleON","onClick","type","onChange","target","htmlFor","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.c8d78524.chunk.js","sourcesContent":["const gridOptions = {\r\n  disableUserInteraction: function () {\r\n    document\r\n      .querySelectorAll('#controlPanel button')\r\n      .forEach((elem) => (elem.disabled = true));\r\n  },\r\n  enableUserInteraction: function () {\r\n    document\r\n      .querySelectorAll('#controlPanel button')\r\n      .forEach((elem) => (elem.disabled = false));\r\n  },\r\n  animationLaunched: false,\r\n  isAnimated: true,\r\n  source: [],\r\n  destination: [],\r\n  isSourceDragged: false,\r\n  isDestinationDragged: false,\r\n  chozenAlgorithmCallback: async () => {},\r\n  matrix: null,\r\n  delay: 0,\r\n  clicked: false,\r\n  wpressed: false,\r\n  sourceDragged: false,\r\n  destinationDragged: false,\r\n  getSize: function () {\r\n    return [this.matrix.length, this.matrix[0].length];\r\n  },\r\n  isSource: function (i, j) {\r\n    return this.matrix[i][j].isSource;\r\n  },\r\n  isDestination: function (i, j) {\r\n    return this.matrix[i][j].isDestination;\r\n  },\r\n  isUnvisited: function (i, j) {\r\n    return ['unvisited', 'unvisited-animated'].includes(\r\n      this.matrix[i][j].class\r\n    );\r\n  },\r\n\r\n  isWall: function (i, j) {\r\n    return ['wall', 'wall-animated'].includes(this.matrix[i][j].class);\r\n  },\r\n  isWeighted: function (i, j) {\r\n    return this.matrix[i][j].weighted;\r\n  },\r\n  isVisited: function (i, j) {\r\n    return ['visited', 'visited-animated'].includes(this.matrix[i][j].class);\r\n  },\r\n  isPath: function (i, j) {\r\n    return ['path', 'path-animated'].includes(this.matrix[i][j].class);\r\n  },\r\n  clearPath: function () {\r\n    for (let row of this.matrix) {\r\n      for (let cell of row) {\r\n        if (\r\n          ['path', 'path-animated', 'visited', 'visited-animated'].includes(\r\n            cell.class\r\n          )\r\n        ) {\r\n          cell.update({\r\n            ...cell,\r\n            class: 'unvisited',\r\n          });\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  clearBoard: function () {\r\n    for (let row of this.matrix) {\r\n      for (let cell of row) {\r\n        cell.update({\r\n          ...cell,\r\n          class: 'unvisited',\r\n          weighted: false,\r\n        });\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport default gridOptions;\r\n","import React, { useState } from 'react';\r\nimport gridOptions from './gridOptions';\r\nimport './style.css';\r\n\r\nexport const Cell = ({ position: { i, j } }) => {\r\n  const [options, setOptions] = useState({\r\n    // class: 'unvisited',\r\n    class: gridOptions.matrix[i][j].class,\r\n    // weighted: false,\r\n    weighted: gridOptions.matrix[i][j].weighted,\r\n    isSource: gridOptions.matrix[i][j].isSource,\r\n    isDestination: gridOptions.matrix[i][j].isDestination,\r\n  });\r\n  gridOptions.matrix[i][j].update = setOptions;\r\n  gridOptions.matrix[i][j].class = options.class;\r\n  gridOptions.matrix[i][j].weighted = options.weighted;\r\n  gridOptions.matrix[i][j].isSource = options.isSource;\r\n  gridOptions.matrix[i][j].isDestination = options.isDestination;\r\n\r\n  let classList =\r\n    'cell ' +\r\n    (options.isSource ? 'source ' : '') +\r\n    (options.isDestination ? 'destination ' : '');\r\n  if (\r\n    // if animation is turned off or source / destination are being dragged (and dropped), then set\r\n    // classes without \"-animated\" suffixes for rendering WITHOUT animation\r\n    gridOptions.isSourceDragged ||\r\n    gridOptions.isDestinationDragged ||\r\n    !gridOptions.isAnimated\r\n  ) {\r\n    classList += options.class + (options.weighted ? ' weight ' : '');\r\n  } else {\r\n    // else add \"-animated\" suffix to the end of the animated classes for rendering WITH animation\r\n    classList +=\r\n      `${options.class}-animated ` +\r\n      (options.weighted ? 'weight-animated ' : '');\r\n  }\r\n\r\n  return (\r\n    <div\r\n      id={i + ',' + j}\r\n      onDragStart={(e) => {\r\n        e.preventDefault();\r\n      }}\r\n      className={classList}\r\n      onMouseDown={(e) => {\r\n        if (e.button !== 0 || gridOptions.animationLaunched) return;\r\n\r\n        gridOptions.clicked = true;\r\n\r\n        if (gridOptions.matrix[i][j].isSource) {\r\n          gridOptions.isSourceDragged = true;\r\n        } else if (gridOptions.matrix[i][j].isDestination) {\r\n          gridOptions.isDestinationDragged = true;\r\n        } else {\r\n          if (!gridOptions.wpressed) {\r\n            setOptions({\r\n              ...options,\r\n              class: options.class === 'wall' ? 'unvisited' : 'wall',\r\n            });\r\n            // gridOptions.matrix[i][j].class = options.class;\r\n          } else if (gridOptions.wpressed) {\r\n            setOptions({\r\n              ...options,\r\n              class: 'unvisited',\r\n              weighted: !options.weighted,\r\n            });\r\n          }\r\n        }\r\n      }}\r\n      onMouseOver={async () => {\r\n        if (\r\n          !gridOptions.clicked ||\r\n          gridOptions.matrix[i][j].isSource ||\r\n          gridOptions.matrix[i][j].isDestination\r\n        )\r\n          return;\r\n\r\n        if (gridOptions.isSourceDragged) {\r\n          const [prevSource_i, prevSource_j] = gridOptions.source;\r\n          const prevSourceOptions =\r\n            gridOptions.matrix[prevSource_i][prevSource_j];\r\n\r\n          gridOptions.matrix[prevSource_i][prevSource_j].update({\r\n            ...prevSourceOptions,\r\n            isSource: false,\r\n          });\r\n          gridOptions.source = [i, j];\r\n\r\n          gridOptions.matrix[i][j].update({\r\n            ...options,\r\n            isSource: true,\r\n          });\r\n          // console.log(gridOptions.matrix);\r\n        } else if (gridOptions.isDestinationDragged) {\r\n          const [prevDestination_i, prevDestination_j] =\r\n            gridOptions.destination;\r\n          const prevDestinationOptions =\r\n            gridOptions.matrix[prevDestination_i][prevDestination_j];\r\n          // console.log(gridOptions);\r\n          gridOptions.matrix[prevDestination_i][prevDestination_j].update({\r\n            ...prevDestinationOptions,\r\n            isDestination: false,\r\n          });\r\n          gridOptions.destination = [i, j];\r\n          gridOptions.matrix[i][j].update({\r\n            ...options,\r\n            isDestination: true,\r\n          });\r\n          // await gridOptions.chozenAlgorithmCallback();\r\n        } else if (gridOptions.wpressed) {\r\n          setOptions({\r\n            ...options,\r\n            class: 'unvisited',\r\n            weighted: !options.weighted,\r\n          });\r\n          // gridOptions.matrix[i][j].class = options.class;\r\n          // gridOptions.matrix[i][j].weighted = options.weighted;\r\n        } else {\r\n          setOptions({\r\n            ...options,\r\n            class: options.class === 'wall' ? 'unvisited' : 'wall',\r\n          });\r\n          // gridOptions.matrix[i][j].class = options.class;\r\n        }\r\n      }}\r\n    ></div>\r\n  );\r\n};\r\n","import React, { useState } from 'react';\r\nimport { Cell } from './Cell';\r\nimport './style.css';\r\n\r\nexport const Row = ({ i, columnCount }) => {\r\n  return (\r\n    <div className=\"row\">\r\n      {new Array(columnCount).fill().map((_, j) => (\r\n        <Cell position={{ i, j }} key={i + ',' + j} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n","import React, { useState, useEffect } from 'react';\r\nimport { Row } from './Row';\r\n// import { bfs, dfs, dijkstra, astar } from './algorithms';\r\n// import { recursiveDivision, randomizedDFS } from './mazeAlgorithms';\r\nimport gridOptions from './gridOptions';\r\nimport './style.css';\r\n\r\nexport const Grid = ({\r\n  rowCount,\r\n  columnCount,\r\n  startNodePosition,\r\n  endNodePosition,\r\n}) => {\r\n  const rows = new Array(rowCount)\r\n    .fill()\r\n    .map((_, i) => <Row key={i.toString()} i={i} columnCount={columnCount} />);\r\n\r\n  gridOptions.matrix = new Array(rowCount);\r\n  for (let i = 0; i < rowCount; ++i) {\r\n    gridOptions.matrix[i] = new Array(columnCount);\r\n    for (let j = 0; j < columnCount; ++j) {\r\n      gridOptions.matrix[i][j] = { class: 'unvisited', weighted: false };\r\n    }\r\n  }\r\n  const [start_i, start_j] = startNodePosition;\r\n  const [end_i, end_j] = endNodePosition;\r\n  gridOptions.matrix[start_i][start_j].isSource = true;\r\n  gridOptions.matrix[end_i][end_j].isDestination = true;\r\n  gridOptions.source = [start_i, start_j];\r\n  gridOptions.destination = [end_i, end_j];\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        onDragStart={(e) => {\r\n          e.preventDefault();\r\n        }}\r\n        className=\"grid\"\r\n        onMouseUp={async (e) => {\r\n          if (e.button !== 0) return;\r\n          if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n            gridOptions.clearPath();\r\n            if (gridOptions.isSourceDragged) {\r\n              const [i, j] = gridOptions.source;\r\n              gridOptions.matrix[i][j].update({\r\n                class: 'unvisited',\r\n                weighted: false,\r\n                isSource: true,\r\n                isDestination: false,\r\n              });\r\n              // console.log(gridOptions.matrix[i][j]);\r\n              // console.log(document.getElementById(i + ',' + j));\r\n            } else if (gridOptions.isDestinationDragged) {\r\n              const [i, j] = gridOptions.destination;\r\n              gridOptions.matrix[i][j].update({\r\n                class: 'unvisited',\r\n                weighted: false,\r\n                isSource: false,\r\n                isDestination: true,\r\n              });\r\n            }\r\n            await gridOptions.chozenAlgorithmCallback();\r\n          }\r\n          gridOptions.isSourceDragged = false;\r\n          gridOptions.isDestinationDragged = false;\r\n          gridOptions.clicked = false;\r\n          gridOptions.wpressed = false;\r\n        }}\r\n        onMouseLeave={async () => {\r\n          if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n            gridOptions.clearPath();\r\n            await gridOptions.chozenAlgorithmCallback();\r\n          }\r\n          gridOptions.clicked = false;\r\n          gridOptions.wpressed = false;\r\n          gridOptions.isSourceDragged = false;\r\n          gridOptions.isDestinationDragged = false;\r\n        }}\r\n      >\r\n        {rows}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n","import gridOptions from './gridOptions';\r\n\r\nexport async function runAlgorithm(name) {\r\n  if (!(name in searchingAlgorithms)) {\r\n    throw new ReferenceError(`Algorithm with name '${name}' is not defined`);\r\n  }\r\n  gridOptions.disableUserInteraction();\r\n  gridOptions.animationLaunched = true;\r\n  await searchingAlgorithms[name]();\r\n  gridOptions.animationLaunched = false;\r\n  gridOptions.enableUserInteraction();\r\n}\r\n\r\nconst animateCell = (state, i, j, time = gridOptions.delay) => {\r\n  return new Promise((resolve) => {\r\n    if (gridOptions.isSourceDragged || gridOptions.isDestinationDragged) {\r\n      // when dragging either source or destination,update current cell immediately WITHOUT animation\r\n      gridOptions.matrix[i][j].update({\r\n        isSource: gridOptions.isSource(i, j),\r\n        isDestination: gridOptions.isDestination(i, j),\r\n        class: state,\r\n        weighted: gridOptions.isWeighted(i, j),\r\n      });\r\n      resolve();\r\n    } else {\r\n      setTimeout(() => {\r\n        gridOptions.matrix[i][j].update({\r\n          isSource: gridOptions.isSource(i, j),\r\n          isDestination: gridOptions.isDestination(i, j),\r\n          class: state,\r\n          weighted: gridOptions.isWeighted(i, j),\r\n        });\r\n        resolve();\r\n      }, time);\r\n    }\r\n  });\r\n};\r\n\r\nexport const searchingAlgorithms = {\r\n  bfs: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.clearPath();\r\n    const mat = gridOptions.matrix;\r\n    const n = mat.length;\r\n    const m = mat[0].length;\r\n    const visited = new Array(n).fill().map((e) => new Array(m).fill(false));\r\n    const isValid = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n    visited[src[0]][src[1]] = true;\r\n    const queue = [{ position: [...src], distance: 0, path: [] }];\r\n    const addends = [\r\n      [0, 1],\r\n      [1, 0],\r\n      [0, -1],\r\n      [-1, 0],\r\n    ];\r\n\r\n    while (queue.length > 0) {\r\n      const current = queue.shift();\r\n\r\n      const { position, distance, path } = current;\r\n      const [x, y] = position;\r\n      path.push([x, y]);\r\n\r\n      await animateCell('visited', x, y);\r\n      visited[x][y] = true;\r\n\r\n      if (x === dst[0] && y === dst[1]) {\r\n        for (let [i, j] of path) {\r\n          await animateCell('path', i, j);\r\n        }\r\n        break;\r\n      }\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (isValid(newX, newY)) {\r\n          if (\r\n            !visited[newX][newY] &&\r\n            !gridOptions.isWall(newX, newY)\r\n            // gridOptions.matrix[newX][newY].class !== 'wall'\r\n          ) {\r\n            visited[newX][newY] = true;\r\n            queue.push({\r\n              position: [newX, newY],\r\n              distance: distance + 1,\r\n              path: [...path, [newX, newY]],\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  dfs: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n\r\n    gridOptions.clearPath();\r\n    await animateCell('unvisited', src[0], src[1]);\r\n    await animateCell('unvisited', src[0], src[1]);\r\n    const visited = new Set();\r\n    let foundPath = [];\r\n    async function search(current, path) {\r\n      const [x, y] = current;\r\n      if (gridOptions.isWall(x, y) || visited.has(x + ',' + y)) return false;\r\n      path.push([x, y]);\r\n      await animateCell('visited', x, y);\r\n      visited.add(x + ',' + y);\r\n      // if ()) return false;\r\n      if (x === dst[0] && y === dst[1]) {\r\n        foundPath = path;\r\n        return true;\r\n      }\r\n      const addends = [\r\n        [-1, 0],\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n      ];\r\n      const n = gridOptions.matrix.length;\r\n      const m = gridOptions.matrix[0].length;\r\n      const isValid = (i, j) => i >= 0 && i < n && j >= 0 && j < m;\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (isValid(newX, newY)) {\r\n          let found = await search([newX, newY], [...path]);\r\n          if (found) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    await search(src, []);\r\n    for (let [i, j] of foundPath) {\r\n      await animateCell('path', i, j);\r\n    }\r\n  },\r\n  dijkstra: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.clearPath();\r\n    const matrix = gridOptions.matrix;\r\n    const n = matrix.length;\r\n    const m = matrix[0].length;\r\n    const unvisited = new Set();\r\n    const prev = new Array(n);\r\n    const distances = new Array(n);\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n      prev[i] = new Array(m).fill(null);\r\n      distances[i] = new Array(m).fill(Infinity);\r\n      for (let j = 0; j < m; ++j) {\r\n        unvisited.add(i + ',' + j);\r\n      }\r\n    }\r\n\r\n    const stringify = (i, j) => i + ',' + j;\r\n    const indexify = (vertex) =>\r\n      vertex ? vertex.split(',').map((idx) => Number(idx)) : [-1, -1];\r\n\r\n    const extractMin = () => {\r\n      // finds the vertex with minimum distance, removes it from the \"unvisited\" set and returns it\r\n      let minDistance = Infinity;\r\n      let minDistanceVertex = null;\r\n      const verticies = unvisited.keys();\r\n      for (let v of verticies) {\r\n        const [i, j] = indexify(v);\r\n        if (distances[i][j] < minDistance) {\r\n          minDistance = distances[i][j];\r\n          minDistanceVertex = v;\r\n        }\r\n      }\r\n      if (!minDistanceVertex) {\r\n        minDistanceVertex = verticies[0];\r\n      }\r\n\r\n      unvisited.delete(minDistanceVertex);\r\n      return indexify(minDistanceVertex);\r\n    };\r\n    const getNeighbors = (v) => {\r\n      const neighbors = [];\r\n      let [x, y] = v;\r\n\r\n      const addends = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n        [-1, 0],\r\n      ];\r\n\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n        if (\r\n          newX >= 0 &&\r\n          newX < n &&\r\n          newY >= 0 &&\r\n          newY < m &&\r\n          !gridOptions.isWall(newX, newY)\r\n        ) {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n\r\n      return neighbors;\r\n    };\r\n\r\n    distances[src[0]][src[1]] = 0;\r\n\r\n    while (unvisited.size > 0) {\r\n      const [x, y] = extractMin();\r\n      if (x === -1 || y === -1) {\r\n        // there is no path\r\n        break;\r\n      }\r\n      await animateCell('visited', x, y);\r\n      if (x === dst[0] && y === dst[1]) {\r\n        // found the shortest path\r\n        break;\r\n      }\r\n      const neighbors = getNeighbors([x, y]);\r\n\r\n      for (let neighbor of neighbors) {\r\n        let [i, j] = neighbor;\r\n\r\n        let v = stringify(i, j);\r\n        if (unvisited.has(v)) {\r\n          const alt = distances[x][y] + (matrix[i][j].weighted ? 5 : 1);\r\n\r\n          if (alt < distances[i][j]) {\r\n            distances[i][j] = alt;\r\n            prev[i][j] = [x, y];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let shortestPath = [];\r\n    if (prev[dst[0]][dst[1]]) {\r\n      let current = dst;\r\n      while (current) {\r\n        shortestPath.push(current);\r\n        current = prev[current[0]][current[1]];\r\n      }\r\n    }\r\n\r\n    shortestPath.reverse();\r\n    for (let [i, j] of shortestPath) {\r\n      await animateCell('path', i, j);\r\n    }\r\n  },\r\n\r\n  astar: async () => {\r\n    const src = gridOptions.source;\r\n    const dst = gridOptions.destination;\r\n    gridOptions.disableUserInteraction();\r\n    gridOptions.clearPath();\r\n    const matrix = gridOptions.matrix;\r\n    const n = matrix.length;\r\n    const m = matrix[0].length;\r\n\r\n    const openSet = new Set();\r\n    const prev = new Array(n);\r\n    const gScore = new Array(n);\r\n    const fScore = new Array(n);\r\n\r\n    const getHeruistic = (i, j) => {\r\n      return Math.abs(i - dst[0]) + Math.abs(j - dst[1]);\r\n    };\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n      gScore[i] = new Array(m).fill(Infinity);\r\n      fScore[i] = new Array(m).fill(Infinity);\r\n      prev[i] = new Array(m);\r\n      for (let j = 0; j < m; ++j) {\r\n        prev[i][j] = null;\r\n      }\r\n    }\r\n\r\n    fScore[src[0]][src[1]] = getHeruistic(src[0], src[1]);\r\n    openSet.add(src[0] + ',' + src[1]);\r\n    gScore[src[0]][src[1]] = 0;\r\n\r\n    const stringify = (i, j) => i + ',' + j; // returns hash value for two indicies of the vertex\r\n    const indexify = (vertex) => vertex.split(',').map((idx) => Number(idx)); // returns two indicies from hash value of the vertex\r\n\r\n    const extractMin = () => {\r\n      // finds the vertex with minimum distance, removes it from the \"openSet\" and returns it\r\n      let minFScore = Infinity;\r\n      let minFScoreVertex = null;\r\n      const verticies = openSet.keys();\r\n\r\n      // find the vertex in openSet with minimum fScore\r\n      for (let v of verticies) {\r\n        const [i, j] = indexify(v);\r\n\r\n        if (fScore[i][j] < minFScore) {\r\n          minFScore = fScore[i][j];\r\n          minFScoreVertex = v;\r\n        } else if (fScore[i][j] === minFScore) {\r\n          // if fscores are equal, choose a vertex with lower herustic score\r\n          let [x, y] = indexify(minFScoreVertex);\r\n          if (getHeruistic(i, j) < getHeruistic(x, y)) {\r\n            minFScore = fScore[i][j];\r\n            minFScoreVertex = v;\r\n          }\r\n        }\r\n      }\r\n\r\n      openSet.delete(minFScoreVertex);\r\n      return indexify(minFScoreVertex);\r\n    };\r\n\r\n    const getNeighbors = (v) => {\r\n      const neighbors = [];\r\n      let [x, y] = v;\r\n\r\n      // addendsd for possible directions we can move from v\r\n      const addends = [\r\n        [0, 1],\r\n        [1, 0],\r\n        [0, -1],\r\n        [-1, 0],\r\n      ];\r\n      for (let [i, j] of addends) {\r\n        let newX = x + i;\r\n        let newY = y + j;\r\n\r\n        // validating possible neighbor coordinates\r\n        if (\r\n          newX >= 0 &&\r\n          newX < n &&\r\n          newY >= 0 &&\r\n          newY < m &&\r\n          matrix[newX][newY].class !== 'wall'\r\n        ) {\r\n          neighbors.push([newX, newY]);\r\n        }\r\n      }\r\n      return neighbors;\r\n    };\r\n\r\n    while (openSet.size > 0) {\r\n      const [x, y] = extractMin(); // extract the node with minimal fScore in openSet and remove it from the set\r\n\r\n      await animateCell('visited', x, y);\r\n\r\n      if (x === dst[0] && y === dst[1]) {\r\n        // prev[x][y].push([x, y]);\r\n        break;\r\n      }\r\n      const neighbors = getNeighbors([x, y]);\r\n\r\n      for (let neighbor of neighbors) {\r\n        let [i, j] = neighbor;\r\n        const tentative_gScore = gScore[x][y] + (matrix[i][j].weighted ? 5 : 1);\r\n\r\n        // await sleepPromise('visited', i, j);\r\n        if (tentative_gScore < gScore[i][j]) {\r\n          gScore[i][j] = tentative_gScore;\r\n          prev[i][j] = [x, y];\r\n          fScore[i][j] = tentative_gScore + getHeruistic(i, j);\r\n          openSet.add(stringify(i, j));\r\n        }\r\n      }\r\n    }\r\n    const shortestPath = [];\r\n\r\n    if (prev[dst[0]][dst[1]]) {\r\n      // if the path found, than construct the shortestPath via backtracking from the destination node\r\n      let currentNode = dst;\r\n      while (currentNode) {\r\n        shortestPath.push(currentNode);\r\n        currentNode = prev[currentNode[0]][currentNode[1]];\r\n      }\r\n    }\r\n\r\n    shortestPath.reverse(); // reversing the path to get it in right order (from source to destination)\r\n\r\n    for (let [i, j] of shortestPath) {\r\n      await animateCell('path', i, j);\r\n    }\r\n    gridOptions.enableUserInteraction();\r\n  },\r\n};\r\n","import gridOptions from './gridOptions';\n\nconst animateCell = (state, i, j, time = gridOptions.delay) => {\n  return new Promise((resolve) => {\n    if (\n      state === 'wall' &&\n      (gridOptions.isSource(i, j) || gridOptions.isDestination(i, j))\n    ) {\n      resolve();\n    } else {\n      setTimeout(() => {\n        gridOptions.matrix[i][j].update({\n          isSource: gridOptions.isSource(i, j),\n          isDestination: gridOptions.isDestination(i, j),\n          class: state,\n          weighted: gridOptions.isWeighted(i, j),\n        });\n        resolve();\n      }, time);\n    }\n  });\n};\n\nexport async function runMazeAlgorithm(name) {\n  if (!(name in mazeAlgorithms)) {\n    throw new ReferenceError(`Algorithm with name '${name}' is not defined`);\n  }\n  gridOptions.disableUserInteraction();\n  gridOptions.animationLaunched = true;\n  await mazeAlgorithms[name]();\n  gridOptions.animationLaunched = false;\n  gridOptions.enableUserInteraction();\n}\n\nconst mazeAlgorithms = {\n  recursiveDivision: async () => {\n    const randInt = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    const chooseOrientation = (height, width) => {\n      let orientation = '';\n      if (height > width) {\n        orientation = 'Horizontal';\n      } else if (height < width) {\n        orientation = 'Vertical';\n      } else {\n        orientation = Math.random() <= 0.5 ? 'Horizontal' : 'Vertical';\n      }\n      return orientation;\n    };\n    const randWallIndex = (from, to) => {\n      let wallIndex = -1;\n      const indicies = [];\n      for (let idx = from; idx <= to; ++idx) {\n        if (idx % 2 !== 0) indicies.push(idx);\n      }\n      if (indicies.length > 0) {\n        let randIndex = randInt(0, indicies.length - 1);\n        wallIndex = indicies[randIndex];\n        // wallIndex = indicies[Math.floor(indicies.length / 2)];\n      }\n\n      return wallIndex;\n    };\n\n    const randHoleIndex = (from, to) => {\n      let holeIndex = -1;\n\n      const indicies = [];\n\n      for (let col = from; col <= to; ++col) {\n        if (col % 2 === 0) indicies.push(col);\n      }\n      if (indicies.length > 0) {\n        let randIndex = randInt(0, indicies.length - 1);\n        holeIndex = indicies[randIndex];\n        // holeIndex = indicies[Math.floor(indicies.length / 2)];\n      }\n\n      return holeIndex;\n    };\n\n    const divide = async (i, height, j, width) => {\n      if (width <= 2 || height <= 2) {\n        return;\n      }\n\n      const orientation = chooseOrientation(height, width);\n\n      if (orientation === 'Horizontal') {\n        const wallIndex = randWallIndex(i + 1, i + height - 2);\n        if (wallIndex === -1) return;\n\n        const holeIndex = randHoleIndex(j, j + width - 1);\n        if (holeIndex === -1) return;\n\n        for (let col = j; col < j + width; ++col) {\n          if (col !== holeIndex) {\n            await animateCell('wall', wallIndex, col);\n          }\n        }\n\n        await divide(i, wallIndex - i, j, width);\n        await divide(wallIndex + 1, i + height - wallIndex - 1, j, width);\n      } else if (orientation === 'Vertical') {\n        let wallIndex = randWallIndex(j + 1, j + width - 2);\n        if (wallIndex === -1) return;\n\n        const holeIndex = randHoleIndex(i, i + height - 1);\n        if (holeIndex === -1) return;\n        for (let row = i; row < i + height; ++row) {\n          if (row !== holeIndex) {\n            await animateCell('wall', row, wallIndex);\n          }\n        }\n        await divide(i, height, j, wallIndex - j);\n        await divide(i, height, wallIndex + 1, j + width - wallIndex - 1);\n      }\n    };\n    const [n, m] = gridOptions.getSize();\n    await divide(0, n, 0, m);\n\n    // check if source or destination are disconnected from the grid (are surrounded by walls),\n    //    if so, randomly remove one of the walls\n\n    const src = gridOptions.source;\n    const sourceNeighbors = [\n      [src[0] + 1, src[1]],\n      [src[0] - 1, src[1]],\n      [src[0], src[1] + 1],\n      [src[0], src[1] - 1],\n    ].filter(([i, j]) => i >= 0 && j >= 0 && i < n && j < m);\n\n    if (sourceNeighbors.every(([i, j]) => gridOptions.isWall(i, j))) {\n      const randIndex = randInt(0, sourceNeighbors.length - 1);\n      await animateCell('unvisited', ...sourceNeighbors[randIndex]);\n    }\n\n    const dst = gridOptions.destination;\n    const destinationNeighbors = [\n      [dst[0] + 1, dst[1]],\n      [dst[0] - 1, dst[1]],\n      [dst[0], dst[1] + 1],\n      [dst[0], dst[1] - 1],\n    ].filter(([i, j]) => i >= 0 && j >= 0 && i < n && j < m);\n\n    if (destinationNeighbors.every(([i, j]) => gridOptions.isWall(i, j))) {\n      const randIndex = randInt(0, destinationNeighbors.length - 1);\n      await animateCell('unvisited', ...destinationNeighbors[randIndex]);\n    }\n  },\n  randomizedDFS: async () => {\n    const [n, m] = gridOptions.getSize();\n    let visited = new Set();\n\n    const stringify = ([x, y]) => x + ',' + y;\n    const randInt = (min, max) =>\n      Math.floor(Math.random() * (max - min + 1)) + min;\n\n    const isVisited = ([x, y]) => {\n      return visited.has(x + ',' + y);\n    };\n\n    const getNeigborsWithDistance = (x, y, distance) => {\n      const neighbors = [];\n      let addends = [\n        [0, distance],\n        [distance, 0],\n        [0, -distance],\n        [-distance, 0],\n      ];\n\n      for (let [i, j] of addends) {\n        let newX = x + i;\n        let newY = y + j;\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m) {\n          neighbors.push([newX, newY]);\n        }\n      }\n      // randomly shuffle with FisherYates algorithm\n      const shuffled = [];\n      while (neighbors.length > 0) {\n        const l = neighbors.length - 1;\n        let randIndex = randInt(0, l);\n        shuffled.push(neighbors[randIndex]);\n\n        const temp = neighbors[randIndex];\n        neighbors[randIndex] = neighbors[l];\n        neighbors[l] = temp;\n\n        neighbors.pop();\n      }\n\n      return shuffled;\n    };\n\n    const getNeigbors = (x, y) => {\n      return getNeigborsWithDistance(x, y, 2);\n    };\n\n    const getHoleNeighbors = (x, y) => {\n      return getNeigborsWithDistance(x, y, 1);\n    };\n\n    const dfs = async (vertex) => {\n      const [i, j] = vertex;\n      if (isVisited(vertex)) return;\n\n      visited.add(stringify(vertex));\n\n      const neighbors = getNeigbors(i, j);\n      for (let neighbor of neighbors) {\n        if (!isVisited(neighbor)) {\n          const wallI = (i + neighbor[0]) / 2;\n          const wallJ = (j + neighbor[1]) / 2;\n          if (!gridOptions.isWall(wallI, wallJ))\n            await animateCell('wall', wallI, wallJ);\n        }\n      }\n      for (let neighbor of neighbors) {\n        if (!isVisited(neighbor)) {\n          const holeI = (i + neighbor[0]) / 2;\n          const holeJ = (j + neighbor[1]) / 2;\n\n          const holeNeighbors = getHoleNeighbors(holeI, holeJ);\n          for (let holeNeighbor of holeNeighbors) {\n            if (\n              !gridOptions.isWall(holeNeighbor[0], holeNeighbor[1]) &&\n              !isVisited(holeNeighbor) &&\n              (neighbor[0] !== holeNeighbor[0] ||\n                neighbor[1] !== holeNeighbor[1])\n            ) {\n              await animateCell('wall', holeNeighbor[0], holeNeighbor[1]);\n            }\n          }\n          await animateCell('unvisited', holeI, holeJ, 0);\n          visited.add(stringify([holeI, holeJ]));\n          await dfs(neighbor);\n        }\n      }\n    };\n\n    await dfs([0, 0]);\n\n    // adding walls to unreachable cells (which are considered to be walls)\n    for (let i = 1; i < n; i += 2) {\n      for (let j = 1; j < m; j += 2) {\n        if (\n          gridOptions.isUnvisited(i, j) &&\n          getHoleNeighbors(i, j).every(([row, col]) => {\n            return gridOptions.isWall(row, col);\n          })\n        ) {\n          await animateCell('wall', i, j);\n        }\n      }\n    }\n  },\n\n  binaryTree: async () => {\n    const [n, m] = gridOptions.getSize();\n    for (let i = 2; i < n; i += 2) {\n      for (let j = 2; j < m; j += 2) {\n        await animateCell('unvisited', i, j);\n        // randomly chooze connection direciton either north or west\n        if (Math.random() <= 0.5) {\n          const passageI = i - 1;\n          const passageJ = j;\n          if (passageI < n && passageJ < m) {\n            await animateCell('wall', i, passageJ - 1);\n            await animateCell('wall', passageI, passageJ - 1);\n          }\n        } else {\n          const passageI = i;\n          const passageJ = j - 1;\n          if (passageI >= 1 && passageI < n && passageJ >= 0 && passageJ < m) {\n            await animateCell('wall', passageI - 1, j);\n            await animateCell('wall', passageI - 1, passageJ);\n          }\n        }\n      }\n    }\n  },\n  primsRandomizedAlgorithm: async () => {\n    const [n, m] = gridOptions.getSize();\n    const visited = new Set();\n    let unvisited = new Set();\n    unvisited.add('16,20');\n\n    const randInt = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    const isVisited = (i, j) => visited.has(i + ',' + j);\n\n    const extractRandomVertexFromUnvisitedSet = () => {\n      const randIndex = randInt(0, unvisited.size - 1);\n      const randVertex = Array.from(unvisited.keys())[randIndex];\n      unvisited.delete(randVertex);\n      return randVertex;\n    };\n    const getVisitedNeigbors = (i, j) => {\n      const neighbors = [\n        [i, j + 2],\n        [i + 2, j],\n        [i, j - 2],\n        [i - 2, j],\n      ];\n      return neighbors.filter(\n        ([r, c]) => r >= 0 && c >= 0 && r < n && c < m && isVisited(r, c)\n      );\n    };\n    const getWallNeighbors = (i, j) => {\n      const neighbors = [\n        [i, j + 1],\n        [i + 1, j],\n        [i, j - 1],\n        [i - 1, j],\n        [i + 1, j + 1],\n        [i + 1, j - 1],\n        [i - 1, j - 1],\n        [i - 1, j + 1],\n      ];\n      return neighbors.filter(\n        ([r, c]) => r >= 0 && c >= 0 && r < n && c < m && !isVisited(r, c)\n      );\n    };\n\n    const getUnvisitedNeigbors = (i, j) => {\n      const neighbors = [\n        [i, j + 2],\n        [i + 2, j],\n        [i, j - 2],\n        [i - 2, j],\n      ];\n      return neighbors.filter(\n        ([r, c]) => r >= 0 && c >= 0 && r < n && c < m && !isVisited(r, c)\n      );\n    };\n    while (unvisited.size > 0) {\n      const vertex = extractRandomVertexFromUnvisitedSet();\n      const [vi, vj] = vertex.split(',').map((e) => Number(e));\n      animateCell('unvisited', vi, vj, 0);\n      for (let [i, j] of getWallNeighbors(vi, vj)) {\n        if (!gridOptions.isWall(i, j)) await animateCell('wall', i, j);\n      }\n      visited.add(vertex);\n      const visitedNeigbors = getVisitedNeigbors(vi, vj);\n      if (visitedNeigbors.length > 0) {\n        const randIndex = randInt(0, visitedNeigbors.length - 1);\n        const randVertex = visitedNeigbors[randIndex];\n        animateCell('unvisited', randVertex[0], randVertex[1], 0);\n        animateCell(\n          'unvisited',\n          (randVertex[0] + vi) / 2,\n          (randVertex[1] + vj) / 2,\n          0\n        );\n      }\n\n      const unvisitedNeigbors = getUnvisitedNeigbors(vi, vj);\n      unvisitedNeigbors.forEach(([i, j]) => {\n        unvisited.add(i + ',' + j);\n      });\n    }\n  },\n};\n","import React, { useState, useEffect } from 'react';\r\nimport { searchingAlgorithms, runAlgorithm } from './algorithms';\r\nimport { runMazeAlgorithm } from './mazeAlgorithms';\r\nimport gridOptions from './gridOptions';\r\nimport './style.css';\r\n\r\nexport const ControlPanel = () => {\r\n  useEffect(() => {\r\n    document.getElementById('speedInput').value = 200;\r\n    document.getElementById('isAnimatedCheckBox').checked = true;\r\n    gridOptions.delay = 0;\r\n\r\n    document.body.addEventListener('keydown', (e) => {\r\n      if (e.key === 'w') {\r\n        gridOptions.wpressed = true;\r\n        gridOptions.wallToggleON = false;\r\n      }\r\n    });\r\n    document.body.addEventListener('keyup', (e) => {\r\n      if (e.key === 'w') {\r\n        gridOptions.wpressed = false;\r\n      }\r\n    });\r\n  });\r\n  return (\r\n    <div id=\"controlPanel\">\r\n      <button\r\n        id=\"bfsBtn\"\r\n        onClick={async () => {\r\n          gridOptions.chozenAlgorithmCallback = searchingAlgorithms.bfs;\r\n          await runAlgorithm('bfs');\r\n        }}\r\n      >\r\n        BFS!\r\n      </button>\r\n\r\n      <button\r\n        id=\"dfsBtn\"\r\n        onClick={async () => {\r\n          gridOptions.chozenAlgorithmCallback = searchingAlgorithms.dfs;\r\n          await runAlgorithm('dfs');\r\n        }}\r\n      >\r\n        DFS!\r\n      </button>\r\n      <button\r\n        id=\"dijkstraBtn\"\r\n        onClick={async () => {\r\n          gridOptions.chozenAlgorithmCallback = searchingAlgorithms.dijkstra;\r\n          await runAlgorithm('dijkstra');\r\n        }}\r\n      >\r\n        Dijkstra's algorithm\r\n      </button>\r\n      <button\r\n        id=\"astarBtn\"\r\n        onClick={async () => {\r\n          gridOptions.chozenAlgorithmCallback = searchingAlgorithms.astar;\r\n          await runAlgorithm('astar');\r\n        }}\r\n      >\r\n        A *\r\n      </button>\r\n      <div className=\"verticalLine\"></div>\r\n      <button\r\n        id=\"recursiveDivisionBtn\"\r\n        onClick={async () => {\r\n          gridOptions.clearBoard();\r\n          await runMazeAlgorithm('recursiveDivision');\r\n        }}\r\n      >\r\n        Recursive Division\r\n      </button>\r\n\r\n      <button\r\n        id=\"randomizedDFSBtn\"\r\n        onClick={async () => {\r\n          gridOptions.clearBoard();\r\n          await runMazeAlgorithm('randomizedDFS');\r\n        }}\r\n      >\r\n        Randomized DFS!\r\n      </button>\r\n      <button\r\n        id=\"binaryTreeBtn\"\r\n        onClick={async () => {\r\n          gridOptions.clearBoard();\r\n          await runMazeAlgorithm('binaryTree');\r\n        }}\r\n      >\r\n        Binary Tree\r\n      </button>\r\n      <button\r\n        id=\"primsRandomizedAlgorithmBtn\"\r\n        onClick={async () => {\r\n          gridOptions.clearBoard();\r\n          await runMazeAlgorithm('primsRandomizedAlgorithm');\r\n        }}\r\n      >\r\n        Prim's randomized\r\n      </button>\r\n      <div className=\"verticalLine\"></div>\r\n      <button\r\n        id=\"clearBoardBtn\"\r\n        onClick={async () => {\r\n          gridOptions.clearBoard();\r\n        }}\r\n      >\r\n        Clear Board!\r\n      </button>\r\n      <button\r\n        id=\"clearPathBtn\"\r\n        onClick={async () => {\r\n          gridOptions.clearPath();\r\n        }}\r\n      >\r\n        Clear Path!\r\n      </button>\r\n\r\n      <input\r\n        id=\"speedInput\"\r\n        type=\"range\"\r\n        min=\"0\"\r\n        max=\"200\"\r\n        onChange={(e) => {\r\n          gridOptions.delay = 200 - Number(e.target.value);\r\n        }}\r\n      />\r\n      <input\r\n        onChange={() => {\r\n          gridOptions.isAnimated = !gridOptions.isAnimated;\r\n        }}\r\n        id=\"isAnimatedCheckBox\"\r\n        type=\"checkbox\"\r\n      />\r\n      <label htmlFor=\"isAnimatedCheckBox\">Animated</label>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\nimport './style.css';\nimport { Grid } from './Grid';\nimport { ControlPanel } from './ControlPanel';\n// import gridOptions from './gridOptions';\n\nexport default function App() {\n  return (\n    <div className=\"flex-box\">\n      <Grid\n        rowCount={31}\n        columnCount={41}\n        startNodePosition={[5, 5]}\n        endNodePosition={[8, 8]}\n      />\n      <ControlPanel />\n    </div>\n  );\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\n\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}